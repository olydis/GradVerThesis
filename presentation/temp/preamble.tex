\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\pagestyle{empty}

\makeatletter
\newcommand*{\shifttext}[2]{%
    \settowidth{\@tempdima}{#2}%
    \makebox[\@tempdima]{\hspace*{#1}#2}%
}
\makeatother

\usepackage[T1]{fontenc}
\newunicodechar{≠}{=\llap{/}}
\newunicodechar{≔}{:\raisebox{-0.18ex}[\height][\depth]{=}}
\newunicodechar{∧}
{\shifttext{1ex}{\begingroup \fontsize{8pt}{8pt}\selectfont {\shifttext{0.4ex}{/}\shifttext{-0.4ex}{\textbackslash}} \endgroup}}
\newunicodechar{∨}
{\shifttext{1ex}{\begingroup \fontsize{8pt}{8pt}\selectfont {\shifttext{0.4ex}{\textbackslash}\shifttext{-0.4ex}{/}} \endgroup}}


%% decoration
\newcommand{\pa}[1]{\ensuremath{{#1}^{\checkmark}}}
\newcommand{\pb}[1]{\ensuremath{{#1}^{\circ}}}

\newcommand{\grad}[1]{\widetilde{#1}}
\newcommand{\dgrad}[1]{\vec{#1}}
\newcommand{\gradT}[1]{\ensuremath{\grad{\text{#1}}}}
\newcommand{\dgradT}[1]{\ensuremath{\dgrad{\text{#1}}}}
\newcommand{\usc}{\rule{1ex}{0.4pt}}

%% ALIASES
% fonts
\newcommand{\std}{\textrm}
\newcommand{\ttt}[1]{\textup{\texttt{#1}}}
\newcommand{\tset}[1]{\textup{\textsc{#1}}}
\newcommand{\predicate}[1]{\textup{\textmd{\textsf{#1}}}}
% names
\newcommand{\svlidf}{\ensuremath{\std{\textbf{SVL}}_{\std{\textbf{IDF}}}}}
\newcommand{\gvlidf}{\ensuremath{\std{\textbf{GVL}}_{\std{\textbf{IDF}}}}}
\newcommand{\svl}{\std{\textbf{SVL}}}
\newcommand{\gvl}{\std{\textbf{GVL}}}

% sets
\newcommand{\setProgramState}{\tset{ProgramState}}
\newcommand{\setProgramStateFin}{\tset{ProgramStateFin}}
\newcommand{\setProgramStateEx}{\tset{ProgramStateEx}}
\newcommand{\setGProgramState}{\tset{\gradT ProgramState}}
\newcommand{\setGProgramStateFin}{\tset{\gradT ProgramStateFin}}
\newcommand{\setGProgramStateEx}{\tset{\gradT ProgramStateEx}}
\newcommand{\setProgram}{\tset{Program}}
\newcommand{\setGProgram}{\tset{\gradT Program}}
\newcommand{\setClass}{\tset{Class}}
\newcommand{\setGClass}{\tset{\gradT Class}}
\newcommand{\setField}{\tset{Field}}
\newcommand{\setMethod}{\tset{Method}}
\newcommand{\setGMethod}{\tset{\gradT Method}}
\newcommand{\setContract}{\tset{Contract}}
\newcommand{\setGContract}{\tset{\gradT Contract}}
\newcommand{\setType}{\tset{Type}}
\newcommand{\setStmt}{\tset{Stmt}}
\newcommand{\setGStmt}{\tset{\gradT Stmt}}
\newcommand{\setFormula}{\tset{Formula}}
\newcommand{\setFormulaA}{\tset{SatFormula}}
\newcommand{\setFormulaB}{\tset{SfrmFormula}}
\newcommand{\setGFormula}{\tset{\gradT Formula}}
\newcommand{\setGFormulaA}{\tset{\gradT SatFormula}}
\newcommand{\setGFormulaB}{\tset{\gradT SfrmFormula}}
\newcommand{\setExpr}{\tset{Expr}}
\newcommand{\setVal}{\tset{Val}}
\newcommand{\setLoc}{\tset{Loc}}
\newcommand{\setVar}{\tset{Var}}

\newcommand{\setHeap}{\tset{Heap}}
\newcommand{\setStack}{\tset{Stack}}
\newcommand{\setStackEntry}{\tset{StackEntry}}
\newcommand{\setVarEnv}{\tset{VarEnv}}
\newcommand{\setTypeEnv}{\tset{TypeEnv}}
\newcommand{\setClassName}{\tset{ClassName}}
\newcommand{\setFieldName}{\tset{FieldName}}
\newcommand{\setMethodName}{\tset{MethodName}}
\newcommand{\setSFootprint}{\tset{StaticFootprint}}
\newcommand{\setDFootprint}{\tset{DynamicFootprint}}

\newcommand{\setNat}{\ensuremath{\mathbb{N}_+}}
\newcommand{\setNatZ}{\ensuremath{\mathbb{N}_0}}
% expressions
\newcommand{\ev}[1]{\ttt{#1}}
\newcommand{\ex}[1]{\ttt{#1}}
\newcommand{\edot}[2]{\ttt{#1.#2}}
\newcommand{\ethis}{\ex{this}}
\newcommand{\eresult}{\ex{result}}
\newcommand{\enull}{\ttt{null}}
% formulas
\newcommand{\phiOr}[2]{\ttt{#1\:∨\:#2}}
\newcommand{\gphiOr}[2]{\ttt{{#1}\:$\grad{\ttt{∨}}$\:{#2}}}
\newcommand{\phiAnd}[2]{\ttt{#1\:∧\:#2}}
\newcommand{\gphiAnd}[2]{\ttt{{#1}\:$\grad{\ttt{∧}}$\:{#2}}}
\newcommand{\phiCons}[2]{\ttt{#1\:*\:#2}}
\newcommand{\gphiCons}[2]{\ttt{#1\:$\grad{\ttt{*}}$\:#2}}
\newcommand{\phiFalse}[0]{\ttt{false}}
\newcommand{\phiTrue}[0]{\ttt{true}}
\newcommand{\phiMapsTo}[2]{\ttt{(#1\:\:$\mapsto$\:\:#2)}}
\newcommand{\phiEq}[2]{\ttt{(#1 = #2)}}
\newcommand{\phiNeq}[2]{\ttt{(#1 ≠ #2)}}
\newcommand{\phiAcc}[2]{\ttt{\textbf{acc}(#1.#2)}}
\newcommand{\qm}{\ttt{?}}
\newcommand{\withqm}[1]{\phiCons{\qm}{\ensuremath{#1}}}
\newcommand{\withqmGen}[1]{\phiAnd{\ensuremath{#1}}{\qm}}
% statements
\newcommand{\sSkip}{\ttt{skip}}
\newcommand{\sFieldAssign}[3]{\ttt{#1.#2 ≔ #3}}
\newcommand{\sVarAssign}[2]{\ttt{#1 ≔ #2}}
\newcommand{\sAlloc}[2]{\ttt{#1 ≔ new #2}}
\newcommand{\sCall}[4]{\ttt{#1 ≔ #2.#3(#4)}}
\newcommand{\sReturn}[1]{\ttt{return #1}}
\newcommand{\sAssert}[1]{\ttt{assert #1}}
\newcommand{\sRelease}[1]{\ttt{release #1}}
\newcommand{\sDeclare}[2]{\ttt{#1~#2}}
\newcommand{\sHold}[2]{\ttt{hold #1~\{ #2 \}}}
\newcommand{\sSeq}[2]{\ttt{{#1};~{#2}}}
% type
\newcommand{\type}[1]{\ttt{#1}}
\newcommand{\Tint}{\type{int}}
% composite syntax
\newcommand{\class}[3]{\ttt{class {#1}~\{ {#2} {#3} \}}}
\newcommand{\method}[6]{\ttt{{#1}~{#2}({#3}~{#4})~{#5}~\{ {#6} \}}}
\newcommand{\contract}[2]{\ttt{requires {#1}; ensures {#2};}}
\newcommand{\field}[2]{\ttt{{#1}~{#2};}}
%% predicates
% precision
\newcommand{\mpt}{\sqsubseteq}
\newcommand{\mpts}{\sqsubseteq_s}
\newcommand{\mptpi}{\sqsubseteq_{\pi}}
% well-formed
\newcommand{\wsp}{\predicate{wsp}}
\newcommand{\verify}{\predicate{verify}}
\newcommand{\OK}{~\predicate{OK}}
\newcommand{\OKinC}{~\predicate{OK in}~C}
\newcommand{\gOK}{~\predicate{\gradT {OK}}}
\newcommand{\gOKinC}{~\predicate{\gradT {OK} in}~C}
% framing
\newcommand{\sfrme}{\ensuremath{\vdash_\texttt{frm}}\,}
\newcommand{\sfrmphi}{\ensuremath{\vdash_\texttt{sfrm}}\,}
\newcommand{\sfrmgphi}{\ensuremath{\grad{\vdash}_\texttt{sfrm}}\,}
\newcommand{\gwo}[2]{#1\grad{\div}#2}
\newcommand{\wo}[2]{#1\div#2}
% evaluation
\newcommand{\evalex}[4]{#1,#2 \vdash #3 \Downarrow #4}
\newcommand{\evale}[2]{H,\rho \vdash #1 \Downarrow #2}
\newcommand{\evalphiXGen}[2]{#1 \vDash_{X} #2}
\newcommand{\evalgphiXGen}[2]{#1 \,\,\grad{\vDash_{X}}\,\, #2}
\newcommand{\evalphiGen}[2]{#1 \,\,{\vDash}\,\, #2}
\newcommand{\evalgphiGen}[2]{#1 \,\,\grad{\vDash}\,\, #2}
\newcommand{\evalphi}[1]{\evalphiGen {H,\rho,A} {#1}}
\newcommand{\evalgphi}[1]{\evalgphiGen {H,\rho,A} {#1}}
\newcommand{\phiImplies}[2]{{#1} \,\,{\Rightarrow}\,\, {#2}}
\newcommand{\phiImpliesEv}[3]{#3 \vdash \phiImplies{#1}{#2}}
\newcommand{\gphiImplies}[2]{{#1} \,\,{\grad{\Rightarrow}}\,\, {#2}}
\newcommand{\gphiImpliesEv}[3]{#3 \vdash \gphiImplies{#1}{#2}}
\newcommand{\evalphix}[4]{\evalphiGen {#1,#2,#3} {#4}}
% extraction
\newcommand{\FV}{\predicate{FV}}
\newcommand{\fieldType}{\predicate{fieldType$_p$}}
\newcommand{\fields}[1]{\predicate{fields$_p$($#1$)}}
\newcommand{\mpre}[1]{\predicate{mpre$_p$($#1$)}}
\newcommand{\mpost}[1]{\predicate{mpost$_p$($#1$)}}
\newcommand{\mmethod}[1]{\predicate{method$_p$($#1$)}}
\newcommand{\topmost}{\predicate{topmost}}
% other
\newcommand{\id}{\predicate{id}}
\newcommand{\nil}{\predicate{nil}}
\newcommand{\static}[1]{\predicate{static(#1)}}
\newcommand{\dom}[1]{\predicate{dom($#1$)}}
\newcommand{\mods}{\predicate{mod}}
\newcommand{\sType}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\defaultValue}[1]{\predicate{defaultValue(#1)}}
\newcommand{\defeq}{\overset{\predicate{def}}{=}}
\newcommand{\defiff}{\overset{\predicate{def}}{\iff}}
\newcommand{\accFor}[1]{\predicate{acc($#1$)}}
% footprint
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
\newcommand{\staticFP}[1]{\ensuremath{\floor{#1}}}
\newcommand{\dynamicFP}[3]{\ensuremath{\floor{#3}_{#1,#2}}}
% static sem
\newcommand{\hoare}[3]{\{{#1}\} ~{#2}~ \{{#3}\}}
\newcommand{\tHoare}[4]{{#1} \,\,{\vDash}\,\, \hoare {#2} {#3} {#4}}
\newcommand{\gtHoare}[4]{{#1} \,\,\grad{\vDash}\,\, \hoare {#2} {#3} {#4}}
\newcommand{\thoare}[4]{{#1} \,\,{\vdash}\,\, \hoare {#2} {#3} {#4}}
\newcommand{\gthoare}[4]{{#1} \,\,\grad{\vdash}\,\, \hoare {#2} {#3} {#4}}
\newcommand{\dgthoare}[4]{{#1} \,\,\dgrad{\vdash}\,\, \hoare {#2} {#3} {#4}}
\newcommand{\PP}{\mathcal{P}}
%\newcommand{\sssem}{\mathcal{S}}
%\newcommand{\gsssem}{\grad{\sssem}}
\newcommand{\funHoare}{\mathcal{H}}
\newcommand{\funHoareA}{\mathcal{F}}
\newcommand{\funHoareApred}{\mathcal{P}}
\newcommand{\funHoareB}{\mathcal{I}}
\newcommand{\funHoareBimp}{\mathcal{J}}
\newcommand{\funHoareC}{\mathcal{M}}
% dyn sem
\newcommand{\prefix}[2]{\predicate{prefix}(#1, #2)}
\newcommand{\progress}{\predicate{progress}_{\sssem}}
\newcommand{\sstepGeneric}[3]{{#1} \,\,{\longrightarrow^{#2}}\,\, {#3}}
\newcommand{\sstepStuck}[1]{{#1} \,\,{\longrightarrow\llap{\shifttext{-4ex}{/}}}\,\, {\,}}
\newcommand{\sstep}[2]{\sstepGeneric {#1} {} {#2}}
\newcommand{\ssteps}[2]{\sstepGeneric {#1} * {#2}}
\newcommand{\sstepConsume}[3]{{#2} \,\,{\overset{#1}{\longrightarrow}}\,\, {#3}}
\newcommand{\gsstepGeneric}[3]{{#1} \,\,{\grad{\longrightarrow}^{#2}}\,\, {#3}}
\newcommand{\gsstepStuck}[1]{{#1} \,\,{\grad{\longrightarrow}\llap{\shifttext{-2.5ex}{/}}}\,\, {\,}}
\newcommand{\gsstep}[2]{\gsstepGeneric {#1} {} {#2}}
\newcommand{\gssteps}[2]{\gsstepGeneric {#1} * {#2}}
\newcommand{\gsstepConsume}[3]{{#2} \,\,{\overset{#1}{\grad{\longrightarrow}}}\,\, {#3}}

\newcommand{\envs}[1]{\llbracket {#1} \rrbracket}
\newcommand{\norm}[1]{\ensuremath{||#1||}}
\newcommand{\norms}[1]{\ensuremath{|#1|}}% DEP
\newcommand{\snorm}[1]{\ensuremath{|#1|}}