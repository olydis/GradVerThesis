% TODO: at some point define what statically verified (verification as part of static semantics, no compilation without verification success) vs dynamically verified (no static measures, only (implicit) runtime cecks) means!

%% why start with static language
As illustrated earlier %MAKE SURE!
gradual verification can be seen as an extension of both static and dynamic verification.
% Both can be seen as the endpoints of the continuum...?
Yet, our approach of “gradualization” formalizes the introduction of the dynamic aspect into a fully static system.
Thus, this %TODO: work, section, chapter?
uses a statically verified language as starting point.
Later %TODO: ref
we will show how a programming language without static verification can be approached.

%% structure of this chapter
% TODO

% TODO: overall approach (lift axiomatic semantics, then think about the places where axiomatic semantics reflect back into the system, e.g. function call)
% reference implementation chapter, explain difference (here: general, there: making use of specifics, optimality, minimal runtime overhead (0 if static, ...) ...)