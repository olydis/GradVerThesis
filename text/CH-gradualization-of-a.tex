%% why static->gradual
As illustrated in section \ref{sec:motivationexamples} gradual verification can be seen as an extension of both static and dynamic verification.
Yet, the approach of “gradualization” (adapted from AGT) derives the gradual semantics in terms of static semantics.
In this chapter we will thus describe our approach of deriving a gradually verified language “{\gvl}” starting with a generic statically verified language “{\svl}”.
An informal description of how to tackle the opposite direction can be found in section \ref{sec:enhancing-an-unverified}.

%% structure of this chapter
Section \ref{sec:a-statically-verified} contains the description of “{\svl}” or rather the assumptions we make about it.
In section \ref{sec:gradual-formulas} we describe the syntax extensions necessary to give programmers the opportunity to deviate from purely static annotations.
We immediately give a meaning to the new “gradual” syntax, driven by the concepts of abstract interpretation.
In section \ref{sec:lifting-predicates-and} we explain “lifting”, a procedure adapting predicates and functions in order for them to deal with gradual parameters.
To guide the following efforts to determine gradual semantics of \gvl, we present gradual soundness in section \ref{ssec:gradual-soundness} and point out the associated challenges.

With the necessary tools for gradualization available, we apply them to the static semantics of \svl in section \ref{sec:abstracting-static-semantics}.
Finally, we develop gradual dynamic semantics in section \ref{sec:abstracting-dynamic-semantics} and show how gradual soundness is achievable.

% reference implementation chapter, explain difference (here: general, there: making use of specifics, optimality, minimal runtime overhead (0 if static, ...) ...)