%% intro
The approach we presented constructs a gradually verified language in terms of a statically verified one.
However, as the example in section \ref{ssec:argument-validation} motivates, gradual verification can also be seen as an extension of the dynamically verified setting.
The main drawbacks of dynamic verification (runtime overhead and potentially late error detection) would be counteracted by using static verification techniques where possible.
A gradual verifier will attempt to prove compliance with annotations (making runtime checks unnecessary) or may detect an inevitable violation of an annotation (detecting an error before the program is executed).
In this section, we will briefly describe how to turn a dynamically verified language into a gradually verified one.

%% dyn ver spectrum
To understand how to approach dynamically verified languages, we have to examine how they fit into the spectrum of a gradually verified one.
The static end is (by construction) the one where all formulas are static and the unknown formula “\qm” is never used.
In contrast, annotating $\qm$ everywhere corresponds to a system that solely relies on runtime checks.
One can further define that leaving out annotations (e.g. precondition, postcondition, or even both) corresponds to an annotation of $\qm$.
A dynamically verified language (say, Java) can be imitated using this process.
Given such a language, the steps are thus as follows:

%% steps
First one has to identify what the goal of a static verification system would be for the language at hand.
Common examples include race-condition avoidance or a no-throw guarantee.
One can then develop a sound Hoare logic that achieves that goal, including syntax extensions to the language that allow leveraging that Hoare logic.
Gradualization can be applied to that system, introducing $\qm$ as a “default formula”, which allows making all newly introduced syntax extensions optional again.
The syntax of the resulting gradually verified language should thus be a superset of the dynamically verified one.
Contracts that were before explicitly realized as runtime checks can now be removed and encoded using the extended syntax.