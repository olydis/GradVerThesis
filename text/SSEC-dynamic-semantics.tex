% MENTION that most of that stuff is completely redundant if soundness holds - and only used to prove just that!
The small-step semantics $\sstep{\cdot}{\cdot} : \setProgramState \rightharpoonup \setProgramState$ of \svlidf are defined inductively in figure \ref{fig:svl-sem-dyn-sstep}.
Note that right-associativity of \ttt{;} and termination of sequences with $\sSkip$ (see section \ref{sec:syntax}) obviates the need for dedicated sequence rules.

Using inductive rules to define a partial function, we have to make sure that at most one result is deducible for every input.
\begin{lemma}[$\sstep{\cdot}{\cdot}$ Well-Defined]
    The small-step semantics of \svlidf is well-defined.
\end{lemma}
\begin{proof}
    For $\sstep{\cdot}{\cdot}$ to be well-defined, at most one result can be deducible per input.
    The rules in figure \ref{fig:svl-sem-dyn-sstep} are syntax directed, so we can focus on individual rules when checking for determinism.
    This can be done by looking at the source of all variables used to construct return values (i.e. the variables used on the right hand side of $\sstep{}{}$ in the conclusion).
    All those variables must either be drawn directly from the input or be uniquely specified using premises.
    
    \tset{\gradT SsSkip}
    $H, \rho, A, s, S$ are directly drawn from the input.
    
    \tset{\gradT SsFieldAssign}
    $\rho, A, s, S$ are directly drawn from the input, $H'$ is defined using premises and depends on the uniqueness of $H, o, f, v_y$.
    These are drawn from input or are result of expression evaluation which is deterministic.
    
    The same approach can be used for all remaining rules.
\end{proof}

\begin{figure}
    \boxed{\sstep{\pi}{\pi}}
    \input{data/svl-sem-dyn-sstep}
    \caption{\svlidf: Small-Step Semantics}
    \label{fig:svl-sem-dyn-sstep}
\end{figure}


% Again, the semantics is implicitly parameterized over some program $p$.