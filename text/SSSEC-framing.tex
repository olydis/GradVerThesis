The integral advantage of IDF is the ability to use heap-dependent predicates in formulas.
In case of \svlidf, this means that fields may be used in formulas.
As illustrated in section \ref{ssec:implicit-dynamic-frames}, a formula must contain accessibility-predicates for all fields it references.
Otherwise, one cannot reason safely about writes to the heap.
% Accessibility-predicates are explicitly tracked as part of formulas and thus reflect a static
In this section we will formalize the requirements 

To guarantee safe reasoning about such formulas, they must contain accessibility predicates for all locations they are referencing.



%% other stuff
For future reference, we give further (non-syntactic) definitions:
\begin{figure}[h]
    \begin{align*}
    	A_s    & \in \setSFootprint &  & =~~ \PP^{\setExpr \times \setFieldName} \\
    	A_d    & \in \setDFootprint &  & =~~ \PP^{\setLoc \times \setFieldName} 
    \end{align*}
    \caption{\svlidf: Further Definitions}
\end{figure}

%An IDF assertion is self-framing if:
%For any state in which the assertion is true,
%it remains true if we replace the heap with any that agrees on the locations to which it requires permissions

\svlidf uses the concepts of implicit dynamic frames to ensure that a statement can only access memory locations (more specifically: fields) which it is guaranteed to have exclusive access to.
This is achieved by explicitly tracking access tokens $\phiAcc{\textit{<expression>}}{\textit{<field>}}$ as part of formulas throughout the entire program during verification.
    
The Hoare rules of \svlidf also make sure that access is never duplicated within or across stack frames, effectively ruling out concurrent access to any field during runtime.

Implicit dynamic frames also allows static reasoning about the values of fields during verification, i.e. as part of verification formulas.
In order to guarantee that such formulas always reflect the program state (preservation), formulas mentioning a certain field must also contain the access token to that very field:
\begin{definition}[Self-Framing]
    A formula is \textbf{self-framing} if it contains access to all fields it mentions.
\end{definition}

% EXAMPLE of verification without self-framing.

\begin{figure}
    \boxed{A_s \sfrme e}
    \input{data/svl-sem-stat-frme}
    \caption{\svlidf: Framing Expressions}
\end{figure}

\begin{figure}
    \boxed{A_s \sfrmphi \phi}
    \input{data/svl-sem-stat-frmphi}
    \caption{\svlidf: Framing Formulas}
\end{figure}

We omit the emptyset... 

\begin{definition}[Self-Framing Formula]
    A formula $\phi$ is \textbf{self-framing} iff
    \begin{displaymath}
    \sfrmphi \phi
    \end{displaymath}
    Let $\setFormulaB \subseteq \setFormulaA$ be the set of \textbf{self-framing and satisfiable} formulas.
\end{definition}


\svl will thus only consider method contracts using self-framing and satisfiable formulas well-formed (see section \ref{sec:well-formedness}).

\begin{figure}
    \boxed{\staticFP {\phi} = A_s}
    \input{data/svl-sem-stat-fp}
    \caption{\svlidf: Static Footprint}
\end{figure}

%IS conservative approximation of formulas that are dynamically framed (not possible precisely anyway!)