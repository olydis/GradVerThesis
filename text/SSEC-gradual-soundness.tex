With the notion of sound gradual lifting we have the tools to gradualize the semantics of \svl, resulting in gradual semantics of \gvl.
More specifically, predicate lifting is applied to the Hoare logic of \svl, resulting in a gradual Hoare logic $\gthoare{~}{\cdot}{\cdot}{\cdot} ~\subseteq~ \setGFormula \times \setGStmt \times \setGFormula$ (see section \ref{sec:abstracting-static-semantics}).
Furthermore, function lifting is applied to the small-step semantics of \svl, resulting in gradual small-step semantics $\gsstep{\cdot}{\cdot} : \setGProgramState \rightarrow \setGProgramState$ (see section \ref{sec:abstracting-dynamic-semantics}).
These semantics will by construction be compatible with the semantics of \svl and comply with the gradual guarantee.

Note however that there is an additional requirement concerning the correct interplay between Hoare logic and small-step semantics, namely soundness.
We define gradual soundness of \gvl as follows:
\begin{mathpar}
    \inferrule* [Right=GProgress]
    {
        ???
    }
    {
        ???
    }
\end{mathpar}
\begin{mathpar}
    \inferrule* [Right=GPreservation]
    {
        \gthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
\end{mathpar}

%% valid gradual Hoare triples
\begin{definition}[Validity of Gradual Hoare Triples]~\\
    \label{def:valid-ghoare-triple}
    A Hoare triple $\hoare{\grad{\phi_{pre}}} {\grad{s}} {\grad{\phi_{post}}}$ is \textbf{valid}, written
    $\gtHoare{}{\grad{\phi_{pre}}} {\grad{s}} {\grad{\phi_{post}}}$
    iff
    \begin{flalign*}
    \forall \grad{\pi_{pre}}, \grad{\pi_{post}} \in \setGProgramState.~ \gsstepConsume{\grad{s}}{\grad{\pi_{pre}}}{\grad{\pi_{post}}} \implies (\evalgphiGen{\grad{\pi_{pre}}}{\grad{\phi_{pre}}} \implies \evalgphiGen{\grad{\pi_{post}}}{\grad{\phi_{post}}})
    \end{flalign*}
    
    This definition is analogous to definition \ref{def:valid-hoare-triple}.
\end{definition}
\begin{lemma}[Compositional Validity of Gradual Hoare Triples]
    \label{lem:comp-gtHoare}
    \begin{displaymath}
    \forall \grad{\phi_1}, \grad{\phi_2}, \grad{\phi_3} \in \setGFormula,\, \grad{s_1}, \grad{s_2} \in \setGStmt.~ \gtHoare{}{\grad{\phi_1}} {\grad{s_1}} {\grad{\phi_2}} ~\wedge~ \gtHoare{}{\grad{\phi_2}} {\grad{s_2}} {\grad{\phi_3}} \implies \tHoare{}{\grad{\phi_1}} {\sSeq{$\grad{s_1}$}{$\grad{s_2}$}} {\grad{\phi_3}}
    \end{displaymath}
\end{lemma}
\begin{proof}
    Analogous to proof of lemma \ref{lem:comp-tHoare}.
\end{proof}

%% ...have nothing to do with gradual lifting
Note that $\gtHoare {~} {\cdot} {\cdot} {\cdot}$ is not a sound gradual lifting of $\tHoare{~}{\cdot}{\cdot}{\cdot}$.
A gradual lifting would declare the Hoare triple $\hoare{\qm}{\sVarAssign{x}{3}}{\phiEq{y}{4}}$ valid due to the existence of a valid instantiation, e.g. $\hoare{\phiEq{y}{4}}{\sVarAssign{x}{3}}{\phiEq{y}{4}}$).
However, this triple is clearly not valid as the postcondition is not guaranteed for all executions satisfying the precondition ($\qm$ is always satisfied).
Recall that sound lifting was introduced in order to comply with the expectations a programmer would have when using a gradual verification system.
The validity predicate $\gtHoare {} {\cdot} {\cdot} {\cdot}$ plays a higher conceptual role (correctness proofs), is invisible to the programmer and therefore not affected by any user experience expectations.

%% clash
Unfortunately, the different concepts collide in the gradual preservation condition.
On the one hand gradual Hoare logic must comply with the gradual guarantee and thus verify $\gthoare{~}{\qm}{\sVarAssign{x}{3}}{\phiEq{y}{4}}$.
On the other hand $\gtHoare{~}{\qm}{\sVarAssign{x}{3}}{\phiEq{y}{4}}$ does not hold since the Hoare triple is invalid.
Gradual preservation is therefore unsatisfiable if formalized as above.

%% moral: we need dynamic checks
This conflict is nothing but a reminder that gradualization is not for free, but may require runtime checks in order to be sound.
With this in mind we can reiterate our approach for preservation.

We extend the set of final states $\setGProgramStateFin$ with a designated exceptional state $\pi_{EX}$, representing failure of a runtime check.
Furthermore we introduce an assertion statement $\sAssert{$\phi$}$ (if not already available) that throws an exception, i.e. steps to $\pi_{EX}$ should the condition not hold.
\begin{example}{Small-Step Semantics for Runtime Assertion}
    \label{ex:ss-ra}
    We assume that $\setProgramState = (\setVar \rightharpoonup \mathbb{Z}) \times \setStmt$ as introduced in example \ref{ex:ps-primitive}.
    Furthermore we assume that there exists a no-operation statement $\sSkip$.
    \begin{mathpar}
        \inferrule* [right=SsAssert~~]
        {
            \evalphiGen{\langle \sigma, \sAssert{$\phi_a$} \rangle}{\phi_a}
        }
        {
            \sstep{\langle \sigma, \sAssert{$\phi_a$} \rangle}{\langle \sigma, \sSkip \rangle}
        }
        \inferrule* [Right=SsAssertEx]
        {
            \neg~ \evalphiGen{\langle \sigma, \sAssert{$\phi_a$} \rangle}{\phi_a}
        }
        {
            \sstep{\langle \sigma, \sAssert{$\phi_a$} \rangle}{\pi_{EX}}
        }
    \end{mathpar}
\end{example}

Preservation of \svl can then be rewritten as
\begin{mathpar}
    \inferrule* [Right=Preservation']
    {
        \thoare{~}{\phi_1}{s}{\phi_2}
    }
    {
        \tHoare{~}{\phi_1}{\sSeq{$s$}{\sAssert{$\phi_2$}}}{\phi_2}
    }
\end{mathpar}
Intuitively, this definition states that an assertion is inserted during compilation whenever Hoare logic is used to derive the premise.
Note that \tset{Preservation'} is derivable from the original definition of \tset{Preservation} in section \ref{sec:a-statically-verified}.
Updating gradual preservation accordingly results in:
\begin{mathpar}
    \inferrule* [Right=GPreservation']
    {
        \gthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\sSeq{$\grad{s}$}{\sAssert{$\grad{\phi_2}$}}}{\grad{\phi_2}}
    }
\end{mathpar}

Note that there is room for an optimized implementation of the injected assertions.
Example:
Deducing $\gthoare {} {\qm} {\sVarAssign{y}{2}} {\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}$ would lead to the injection of $\sAssert{\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}$.
However, it is known that $\phiEq{y}{2}$ holds after the assignment, making it legal to instead only assert $\phiEq{x}{3}$.

% address fact that checking that is expensive => would be cool to have static guaranteed knowledge to reduce checking => deterministic lifting...