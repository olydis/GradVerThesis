%% intro, aliasing problem
Reasoning about programs using shared mutable data structures (the default in object orientation) is not possible using traditional Hoare logic.
The following Hoare triple should not be verifiable using a sound Hoare logic due to potential aliasing.
\begin{displaymath}
\hoare
{\phiAnd{\phiEq{p1.age}{19}}{\phiEq{p2.age}{19}}}
{\ttt{p1.age++}}
{\phiAnd{\phiEq{p1.age}{20}}{\phiEq{p2.age}{19}}}
\end{displaymath}
The problem is that \ttt{p1} and \ttt{p2} might be aliases, meaning that they reference the same memory.
The increment operation would thus also affect \ttt{p2.age}, rendering the postcondition invalid.
As we will demonstrate gradual verification on a Java-like language in chapter \ref{ch:case-study--implicit}, we need a logic that is capable of dealing with mutable data structures.

%% SL
Separation logic \cite{reynolds2002separation} is an extension of Hoare logic that explicitly tracks mutable data structures (i.e. heap references) and adds a “separating conjunction” to the formula syntax.
In contrast to ordinary conjunction (\ttt{∧}),
separating conjunction (\ttt{*}) ensures that both sides of the conjunction reference disjoint areas of the heap.
The following Hoare triple would thus be verifiable:
\begin{displaymath}
\hoare
{\phiCons{\phiMapsTo{p1.age}{19}}{\phiMapsTo{p2.age}{19}}}
{\ttt{p1.age++}}
{\phiCons{\phiMapsTo{p1.age}{20}}{\phiMapsTo{p2.age}{19}}}
\end{displaymath}
Note also the changed syntax explicitly tracking the values of certain heap locations.

%% IDF
A drawback of separation logic is that formulas cannot contain heap-dependent expressions (e.g. $\ttt{p1.age > 19}$) as they are not directly expressible using the explicit syntax for heap references.
Implicit dynamic frames (IDF) \cite{smans2009implicit} addresses this issue by decoupling the concept of access to a certain heap location from assertions about its value.
It introduces an “accessibility predicate” \ttt{acc(\textit{loc})} that represents the permission to access \textit{loc}.
Above example can be rewritten in terms of IDF:
\begin{displaymath}
\hoare
{\phiCons {\phiCons{\phiAcc{p1}{age}}{\phiAcc{p2}{age}}} {\phiCons{\phiEq{p1.age}{19}}{\phiEq{p2.age}{19}}}}
{\ttt{p1.age++}}
{\phiCons {\phiCons{\phiAcc{p1}{age}}{\phiAcc{p2}{age}}} {\phiCons{\phiEq{p1.age}{20}}{\phiEq{p2.age}{19}}}}
\end{displaymath}
The separating conjunction makes sure that the accessibility predicates mention disjoint memory locations, whereas it has no further meaning for “ordinary” predicates like equality.




Reasoning about concurrent programs is not possible using traditional Hoare logic.
Consider the following Hoare triple:
\begin{displaymath}
\hoare{\ttt{person ≠ \enull}}{\sSeq{\sFieldAssign{person}{age}{18}}{\ttt{person.age++}}}{\ttt{person.age = 19}}
\end{displaymath}
In case the programming language supports parallelism or any form of preemptive context switching, this Hoare triple should be deducible by a sound Hoare logic.
Other code may have access to \ttt{person} and thus overwrite the \ttt{age}-field concurrently, resulting in arbitrary values of when execution reaches the end of above two statements.


in the way it treats heap references.


Hoare logic has been extended in order to enable reasoning concurrent programs.

Race-free Assertion language! => static verification tool able to reason soundly about concurrent programs

% separating conjuction (= Multiplicative conjunction ⊗, lollipop, ...), access is resource, cannot duplicate access, ...
% TODO: explain Frame Problem
% translation of separating conjuction to regular conjunction? would simplify later reasoning A LOT



\cite{leino2009verification}
Chalice, a verification methodology based on implicit dynamic frames

Chalice’s verification methodology centers around permissions and permission transfer. In particular, a memory location may be accessed by a thread only if that thread has permission to do so. Proper use of permissions allows Chalice to deduce upper bounds on the set of locations modifiable by a method and guarantees the absence of data races for concurrent programs. The lecture notes informally explain how Chalice works through various examples.

also: Viper (Verification Infrastructure for Permission-based Reasoning; is a suite of tools developed at ETH Zurich, providing an architecture on which new verification tools and prototypes can be developed simply and quickly.) has Chalice as front-end

\cite{summers2013formal}
In this paper, we provide both an isorecursive and an equirecursive formal
semantics for recursive definitions in the context of Chalice

\cite{parkinson2011relationship}
VERY IMPORTANT: chapter 2.2

Finally, we show that we can encode the separation
logic fragment of our logic into the implicit dynamic frames fragment, preserving
semantics. For the connectives typically supported by tools, this shows that separation
logic can be faithfully encoded in a first-order automatic verification tool (Chalice).

Although IDF was partially inspired by separation logic, there are many differences
between SL and IDF that make understanding their relationship difficult. SL does not
allow expressions that refer to the heap, while IDF does. SL is defined on partial heaps,
while IDF is defined using total heaps and permission masks. The semantics of IDF are only defined by its translation to first-order verification conditions, while SL has a direct
Kripke semantics for its assertions.

