%% intro, aliasing problem
Reasoning about programs using shared mutable data structures (the default in object orientation) is not possible using traditional Hoare logic.
The following Hoare triple should not be verifiable using a sound Hoare logic due to potential aliasing.
\begin{displaymath}
\hoare
{\phiAnd{\phiEq{p1.age}{19}}{\phiEq{p2.age}{19}}}
{\ttt{p1.age++}}
{\phiAnd{\phiEq{p1.age}{20}}{\phiEq{p2.age}{19}}}
\end{displaymath}
The problem is that \ttt{p1} and \ttt{p2} might be aliases, meaning that they reference the same memory.
The increment operation would thus also affect \ttt{p2.age}, rendering the postcondition invalid.
As we will demonstrate gradual verification on a Java-like language in chapter \ref{ch:case-study--implicit}, we need a logic that is capable of dealing with mutable data structures.

%% SL
Separation logic \cite{reynolds2002separation} is an extension of Hoare logic that explicitly tracks mutable data structures (i.e. heap references) and adds a “separating conjunction” to the formula syntax.
In contrast to ordinary conjunction (\ttt{∧}),
separating conjunction (\ttt{*}) ensures that both sides of the conjunction reference disjoint areas of the heap.
The following Hoare triple would thus be verifiable:
\begin{displaymath}
\hoare
{\phiCons{\phiMapsTo{p1.age}{19}}{\phiMapsTo{p2.age}{19}}}
{\ttt{p1.age++}}
{\phiCons{\phiMapsTo{p1.age}{20}}{\phiMapsTo{p2.age}{19}}}
\end{displaymath}
Note also the changed syntax explicitly tracking the values of certain heap locations.

%% IDF
A drawback of separation logic is that formulas cannot contain heap-dependent expressions (e.g. $\ttt{p1.age > 19}$) as they are not directly expressible using the explicit syntax for heap references.
Implicit dynamic frames (IDF) \cite{smans2009implicit} addresses this issue by decoupling the concept of access to a certain heap location from assertions about its value.
It introduces an “accessibility predicate” \ttt{acc(\textit{loc})} that represents the permission to access \textit{loc}.
Parkinson and Summers \cite{parkinson2011relationship} worked out the formal relationship between separation logic and IDF.
Above example can be rewritten in terms of IDF:
\begin{mathpar}
\{\phiCons {\phiCons{\phiAcc{p1}{age}}{\phiAcc{p2}{age}}} {\phiCons{\phiEq{p1.age}{19}}{\phiEq{p2.age}{19}}}\}\\
{\ttt{p1.age++}}\\
\{\phiCons {\phiCons{\phiAcc{p1}{age}}{\phiAcc{p2}{age}}} {\phiCons{\phiEq{p1.age}{20}}{\phiEq{p2.age}{19}}}\}
\end{mathpar}
The separating conjunction makes sure that the accessibility predicates mention disjoint memory locations, whereas it has no further meaning for non-access predicates like equality.
As formulas can mention heap locations in arbitrary predicates, it has to be ensured that the same formula contains accessibility predicates to all heap locations mentioned.
This property of formulas is called “self-framing”.
Above pre- and postconditions are self-framing whereas the sub-formula $\phiEq{p1.age}{20}$ would not be.
It is essential that access cannot be duplicated and thus also not be shared between threads, allowing race-free reasoning about concurrent programs.

%% Chalice
Implicit dynamic frames was implemented as part of the Chalice verifier \cite{leino2009verification}.
Chalice is also the name of the underlying simple imperative programming language that has constructs for thread creation and thus relies on IDF for sound race-free reasoning.
Chalice was also implemented as a front-end of the Viper toolset. % developed at ETH Zürich.

%% formal semantics
The static semantics of our example language in chapter \ref{ch:case-study--implicit} are based on the Hoare logic for Chalice given by Summers and Drossopoulou \cite{summers2013formal}.


