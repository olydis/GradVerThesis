
...continuation...

Therefore the introduction of gradual statements $\setGStmt$ leads to a notion of gradual program states $\setGProgramState \supseteq \setProgramState$.
TODO: $\setGProgramState_{\grad{s}}$

Again, we give meaning to gradual program states using concretization.
\begin{definition}[Concretization of Gradual Program States]
    Let $\gamma_{\pi} : \setGProgramState \rightarrow \PP(\setProgramState)$ be defined as
    \begin{displaymath}
    \gamma_{\pi}(\grad{\pi}) = \{~ \pi \in \setProgramState ~|~ \textit{$\pi$ is $\grad{\pi}$ with all continuations??? replaced by a concretization} ~\}
    \end{displaymath} 
\end{definition}
\begin{definition}[Precision of Gradual Program States]
    Let $\mptpi \subseteq \setGProgramState \times \setGProgramState$ be a predicate defined as
    $$\grad{\pi_a} \mptpi \grad{\pi_b}  \quad\iff\quad  \gamma_{\pi}(\grad{\pi_a}) \subseteq \gamma_{\pi}(\grad{\pi_b})$$
    % TODO: observational instead... otherwise gradual release or call would not work
\end{definition}

Consequence:
\begin{displaymath}
\forall \grad{\pi_{\grad{s}}} \in \setGProgramState_{\grad{s}}, \pi \in \gamma_{\pi}(\grad{\pi_{\grad{s}}}).~ \exists s \in \gamma_s(\grad{s}).~ \pi \in \setProgramState_s
\end{displaymath}

We demand that formula semantics are not affected by this extension, which is trivially the case if evaluation does not depend on the remaining work in the first place.
Formally: $$\forall \phi \in \setFormula, \grad{\pi} \in \setGProgramState, \pi \in \gamma_{\pi}(\grad{\pi}).~~ \evalphiGen{\grad{\pi}}{\phi} \iff \evalphiGen{\pi}{\phi}$$
