Recall that program state has a notion of continuation, see section \ref{sec:a-statically-verified} for examples.
As the set of possible statements has been augmented from $\setStmt$ to $\setGStmt$, this notion might have to be augmented as well in order to allow encoding the additional statements.

This augmentation leads to a superset $\setGProgramState \supseteq \setProgramState$ of gradual program states.
\begin{example}{Gradual Program State}
\label{ex:grad-ps}
$$\setProgramState ~  =~ (\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt$$
is extended to
$$\setGProgramState ~ =~ (\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setGStmt$$
\end{example}

Concretization and precision are defined accordingly, drawing on concretization of gradual statements.

\begin{comment}
Consequence:
\begin{displaymath}
\forall \grad{\pi_{\grad{s}}} \in \setGProgramState_{\grad{s}}, \pi \in \gamma_{\pi}(\grad{\pi_{\grad{s}}}).~ \exists s \in \gamma_s(\grad{s}).~ \pi \in \setProgramState_s
\end{displaymath}
\end{comment}

\begin{lemma}[Gradual Program State Does Not Affect Formula Semantics]
    \label{lemma:gradPS-form-sem}~\\
    We demand that formula semantics are not affected by gradualization of the program state:
    \begin{displaymath}
    \forall \phi \in \setFormula, \grad{\pi} \in \setGProgramState, \pi \in \gamma_{\pi}(\grad{\pi}).~~ \evalphiGen{\grad{\pi}}{\phi} \iff \evalphiGen{\pi}{\phi}
    \end{displaymath}
    
    This is trivially the case if evaluation does not depend on the (now gradual) continuation in the first place.
\end{lemma}

