Program states as used by small step semantics must contain some notion of “remaining work”, often in form of a statement.
TODO: reasonable to call that “continuation”?

Examples:
\begin{displaymath}
\setProgramState ~=~ \underbrace{(\setVar \rightharpoonup \mathbb{Z})}_{\textit{state for evaluation???}} ~\times~ \setStmt
\end{displaymath}
\begin{displaymath}
\setProgramState ~=~ \underbrace{\Big((\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt \Big)}_{\textit{stack frame}} ~\times~ \Big(\setProgramState ~\cup\, \bot\Big)
\end{displaymath}

Therefore the introduction of gradual statements $\setGStmt$ leads to a notion of gradual program states $\setGProgramState \supseteq \setProgramState$.
TODO: $\setGProgramState_{\grad{s}}$

Again, we give meaning to gradual program states using concretization.
\begin{definition}[Concretization of Gradual Program States]
    Let $\gamma_{\pi} : \setGProgramState \rightarrow \PP(\setProgramState)$ be defined as
    \begin{displaymath}
    \gamma_{\pi}(\grad{\pi}) = \{~ \pi \in \setProgramState ~|~ \textit{$\pi$ is $\grad{\pi}$ with all continuations??? replaced by a concretization} ~\}
    \end{displaymath}
\end{definition}

Consequence:
\begin{displaymath}
\forall \grad{\pi_{\grad{s}}} \in \setGProgramState_{\grad{s}}, \pi \in \gamma_{\pi}(\grad{\pi_{\grad{s}}}).~ \exists s \in \gamma_s(\grad{s}).~ \pi \in \setProgramState_s
\end{displaymath}

We demand that formula semantics are not affected by this extension, which is trivially the case if evaluation does not depend on the remaining work in the first place.
Formally: $$\forall \phi \in \setFormula, \grad{\pi} \in \setGProgramState, \pi \in \gamma_{\pi}(\grad{\pi}).~~ \evalphiGen{\grad{\pi}}{\phi} \iff \evalphiGen{\pi}{\phi}$$
