
\subsection{Argument Validation}
The following Java example motivates the use of verification for argument validation.
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    // business logic:
    resAllocate();
    boolean result = c.driver.age >= 18;
    resFree();
    return result;
}
\end{lstlisting}
A call to \ttt{hasLegalDriver} fails if \ttt{c} or \ttt{c.driver} evaluate to \ttt{null}.
Note that, although the Java runtime has defined behavior in to those cases (throwing an exception), we might still have created a resource leak.
To prevent this from happening, arguments have to be validated before entering the business logic.
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    if (!(c != null))
        throw new IllegalArgException("expected c != null");
    if (!(c.driver != null))
        throw new IllegalArgException("expected c.driver != null");
        
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

Note that these runtime checks dynamically verifies a method contract, having \ttt{c != null \&\& c.driver != null} as precondition.
Naturally, the drawbacks of dynamic verification apply:
Violations of the method contract are only detected at runtime, possibly go unnoticed for a long time and impose a runtime overhead which might not be acceptable in all scenarios.
Java even has dedicated assertion syntax simplifying dynamic verification:
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    assert c != null;
    assert c.driver != null;

    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}
Note however that such assertions are dropped from regular builds, meaning that the method contract is no longer verified!

With support of additional tools, a more declarative approach is possible using JML syntax:
\begin{lstlisting}
//@ requires c != null && c.driver != null;
boolean hasLegalDriver(Car c)
{
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

There are two basic ways to turn this annotation into a guarantee:
\begin{description}
    \item[Static Verification (e.g. ESC/Java, see \cite{leino2000esc})]~\\
    Verification will only succeed if the precondition is provable at all call sites.
    This is achievable in two ways:
    \begin{itemize}
        \item
        Rigorously annotate the call sites, guiding the verifier towards a proof.
        \item 
        Add parameter validation to the call sites, effectively duplicating the original runtime check across the program.
        Note that this approach combines static and dynamic validation in order to get a performance benefit (no more runtime checks required where precondition was provable) and circumvent rigorous annotation.
        The drawback is of course code duplication.
    \end{itemize}
    % benefits, drawbacks
    
    %There are obvious limitations to this approach, static verification tends to be invasive.
    %At least there is a performance benefit: 
    %Runtime checks (originally part of every call) are now only necessary in places where verification would not succeed otherwise.
    
    \item[Dynamic Verification (e.g. run JML4c, see \cite{sarcar2010new}]~\\
    This approach basically converts the annotation back into a runtime check equivalent to our original argument validation.
    % benefits, drawbacks
\end{description}

A gradual verifier would pursue the combined approach without (visible) code duplication:
It would try verifying the contract statically but resort to dynamic methods in case this fails.
As a result, there are no further obligation 

\subsection{Statically Verified Setting}
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 0 < start;
    ensures  0 < result;
{
    // ...
}

int myRandom(int seed)
    requires 0 < seed   && seed   < 10000;
    ensures  0 < result && result < 4;     // not provable
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}

Non-solution:
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 0 < start;
    ensures  0 < result;
{
    // ...
}

int myRandom(int seed)
    requires 0 < seed   && seed   < 10000;
    ensures  0 < result && result < 4;
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    // "cast"
    if (!(result < 5))
        throw new IllegalStateException("expected result < 5");

    // verifier now knows:  0 < result && result < 5 
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}
This solution is not satisfying, 
- much to write, have to think about what to write (requires you to kind of thing from verifiers perspective)
- intuitively the problem is with the method's postcondition being too weak, i.e. we solved the problem at the wrong place!


\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 0 < start;
    ensures  0 < result && ?;
{
    // ...
}

int myRandom(int seed)
    requires 0 < seed   && seed   < 10000;
    ensures  0 < result && result < 4;
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    // verifier allowed to
    //  assume 0 < result && result < 5
    //  from   0 < result && ?
    // (adding runtime check)
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}

% gradual:
% - not in a sense of GraVy
% - assertions are GUARANTEED not to be violated (analogous to type safety of gradually typed languages), meaning that
%    - as much as possible is verified statically
%    - if necessary, (ideally: as few as possible) dynamic checks kick in
% - full continuum between static and dynamic

% static checking
% dynamic checking
% combine static and dynamic checking
% views:
% - add designated "?" to statically checked language, making checking optional
% - introduce checking to unchecked language, making "?" the default value
% typing
% transition to verification
% - of particular interest, cause limitations due to syntax or decidability make full checking impossible,
%    possibly making use of static verification impossible and the program thus unverifiable
%    inevitable incompleteness of static verifiers!
%    GraVy: measure, only \textit{classifies} code into sections: correctness statically guaranteed, correctness statically disproved, no static guarantee so far

% very desirable in practice
% gradual version of a language is inherently a strict superset of original language
% 

% our approach allows extension of existing languages (without any verification) by adding transpilation step

% why would you want continuum?
% - move toward satically verified program without giving up guarantees!
% - while "barely typed" languages hardly make sense, programs with "little verification" are already highly useful
%    i.e. verification even makes sense as "rarely used feature"!
%    ArgumentException-example
%    -    performance benefit!
%    -    cleaner code!
%    -    makes more sense semantically
% having optional types 

% Future Work:
% implement on top of existing languages
% - tracking access via ThreadLocalStorage
% - transpilation (e.g. C# Roslyn compiler extension)