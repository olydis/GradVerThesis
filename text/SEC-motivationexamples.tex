
\subsection{As extension to unverified setting}
“Make dynamic setting more static”

\definecolor{cogreen}{RGB}{0,80,0}
\lstset{
    language=Java,
    basicstyle=\ttfamily,
    commentstyle=\ttfamily,
    frame=single,
    framesep=5pt,
    mathescape=true,
    %escapeinside={(*}{*)},
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{darkgray}\ttfamily,
    commentstyle=\color{cogreen}\ttfamily,
    morekeywords={requires, ensures}
    }

Motivating example:
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    return c.driver.age >= 18;
}
\end{lstlisting}

Motivating example with potential leak:
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    allocateSomething();
    boolean result = c.driver.age >= 18;
    releaseSomething();
    return result;
}
\end{lstlisting}

Motivating example with argument validation:
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    if (!(c != null))
        throw new IllegalArgumentException("expected c != null");
    if (!(c.driver != null))
        throw new IllegalArgumentException("expected c.driver != null");
        
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

Motivating example with declarative approach (JML syntax):
\begin{lstlisting}
//@ requires c != null && c.driver != null;
boolean hasLegalDriver(Car c)
{
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

There are two basic ways to turn this annotation into a guarantee:
\begin{description}
    \item[Static Verification (run ESC/Java \cite{leino2000esc})]~\\
    In the unlikely event that the verifier can prove the precondition at all call sites, our problem is solved.
    Otherwise, we have to enhance the call sites in order to convince the verifier.
    Choices:
    \begin{itemize}
        \item 
        Add parameter validation, effectively duplicating the original runtime check across the program.
        \item
        Add further annotations, guiding the verifier towards a proof.
        This might not always work due to limitations of the verifier or decidability in general.
    \end{itemize}
    There are obvious limitations to this approach, static verification tends to be invasive.
    At least there is a performance benefit: 
    Runtime checks (originally part of every call) are now only necessary in places where verification would not succeed otherwise.
    
    \item[Runtime Assertion Checking (RAC, run JML4c, TODO: http://www.cs.utep.edu/cheon/download/jml4c/doc.php)]~\\
    This approach basically converts the annotation back into a runtime check equivalent to our manual argument validation.
    It is therefore less invasive, not requiring further changes to the code, but also lacks the advantages of static verification.
\end{description}

\subsection{As extension to fully verified setting}
“Make static setting more dynamic”

\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 0 < start;
    ensures  0 < result;
{
    // ...
}

int myRandom(int seed)
    requires 0 < seed   && seed   < 10000;
    ensures  0 < result && result < 4;     // not provable
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}

Non-solution:
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 0 < start;
    ensures  0 < result;
{
    // ...
}

int myRandom(int seed)
    requires 0 < seed   && seed   < 10000;
    ensures  0 < result && result < 4;
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    // "cast"
    if (!(result < 5))
        throw new IllegalStateException("expected result < 5");

    // verifier now knows:  0 < result && result < 5 
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}
This solution is not satisfying, 
- much to write, have to think about what to write (requires you to kind of thing from verifiers perspective)
- intuitively the problem is with the method's postcondition being too weak, i.e. we solved the problem at the wrong place!


\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 0 < start;
    ensures  0 < result && ?;
{
    // ...
}

int myRandom(int seed)
    requires 0 < seed   && seed   < 10000;
    ensures  0 < result && result < 4;
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    // verifier allowed to
    //  assume 0 < result && result < 5
    //  from   0 < result && ?
    // (adding runtime check)
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}

% gradual:
% - not in a sense of GraVy
% - assertions are GUARANTEED not to be violated (analogous to type safety of gradually typed languages), meaning that
%    - as much as possible is verified statically
%    - if necessary, (ideally: as few as possible) dynamic checks kick in
% - full continuum between static and dynamic

% static checking
% dynamic checking
% combine static and dynamic checking
% views:
% - add designated "?" to statically checked language, making checking optional
% - introduce checking to unchecked language, making "?" the default value
% typing
% transition to verification
% - of particular interest, cause limitations due to syntax or decidability make full checking impossible,
%    possibly making use of static verification impossible and the program thus unverifiable
%    inevitable incompleteness of static verifiers!
%    GraVy: measure, only \textit{classifies} code into sections: correctness statically guaranteed, correctness statically disproved, no static guarantee so far

% very desirable in practice
% gradual version of a language is inherently a strict superset of original language
% 

% our approach allows extension of existing languages (without any verification) by adding transpilation step

% why would you want continuum?
% - move toward satically verified program without giving up guarantees!
% - while "barely typed" languages hardly make sense, programs with "little verification" are already highly useful
%    i.e. verification even makes sense as "rarely used feature"!
%    ArgumentException-example
%    -    performance benefit!
%    -    cleaner code!
%    -    makes more sense semantically
% having optional types 

% Future Work:
% implement on top of existing languages
% - tracking access via ThreadLocalStorage
% - transpilation (e.g. C# Roslyn compiler extension)