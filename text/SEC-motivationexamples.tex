
\subsection{Argument Validation}
\label{ssec:argument-validation}
The following Java example motivates the use of verification for argument validation.
\begin{lstlisting}
// spec: no resource leaks
boolean hasLegalDriver(Car c)
{
    // business logic:
    resAllocate();
    boolean result = c.driver.age >= 18;
    resFree();
    return result;
}
\end{lstlisting}
A call to \ttt{hasLegalDriver} fails if \ttt{c} or \ttt{c.driver} evaluate to \ttt{null}.
Note that, although the Java runtime has defined behavior in those cases (throwing an exception), we have created a resource leak.
To prevent this from happening, arguments have to be validated before entering the business logic.
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    if (!(c != null))
        throw new IllegalArgException("expected c != null");
    if (!(c.driver != null))
        throw new IllegalArgException("expected c.driver != null");
        
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

Note that these runtime checks dynamically verify a method contract, having \ttt{c != null \&\& c.driver != null} as precondition.
Naturally, the drawbacks of dynamic verification apply:
Violations of the method contract are only detected at runtime, possibly go unnoticed for a long time and impose a runtime overhead which might not be acceptable in all scenarios.

Java even has a dedicated assertion syntax, simplifying dynamic verification:
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    assert c != null;
    assert c.driver != null;

    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

Using additional tools, a more declarative approach is possible using JML syntax:
\begin{lstlisting}
//@ requires c != null && c.driver != null;
boolean hasLegalDriver(Car c)
{
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

Using JML4c (see \cite{sarcar2010new}) or similar tools, this annotations is compiled back into equivalent runtime assertions.
However, the declarative approach also enables the use of static verification tools like ESC/Java (see \cite{leino2000esc}) to ensure at compile time that every call to \ttt{hasLegalDriver} adheres to the method contract.
Static verification will only succeed if the precondition is provable at all call sites.

Gradual verification would pursue a combined approach without drawbacks:
Static verification is used where possible, dynamic verification where needed.
Where static verification proves a violation of the method contract, an error is found at compile time (which would have required tests with full code coverage to detect otherwise).
Where static verification proves compliance with the method contract, no runtime checks are emitted in order to enforce the contract.
Only call sites which are provable neither to violate nor to adhere with the contract will be enhanced with runtime assertions.



\subsection{Limitations of Static Verification}
\label{ssec:limitations-of-static}
The following example is written in a Java-like language with dedicated syntax for method contracts (similar to Eiffel and Spec\#).
We assume that this language is statically verified, i.e. static verification is part of the compilation.

The example shows the limitations of static verification using the Collatz sequence as an algorithm too complex to describe concisely in a method contract:
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 1 <= start;
    ensures  1 <= result;
{
    // ...
}

int myRandom(int seed)
    requires 1 <= seed   && seed   <= 10000;
    ensures  1 <= result && result <= 3;     // not provable
{
    int result = collatzIterations(300, seed);
    // we know:        result $\in$ { 1, 2, 4 }
    // verifier knows: 1 <= result
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}
The first method \ttt{collatzIterations} iterates given number of times, starting at given value.
We assume that the only provable contract is that positive start value results in positive result.
The second method \ttt{myRandom} uses the Collatz sequence to generate a pseudo random number from given seed.
It is known to the programmer that start values up to 10000 result in convergence of the sequence after 300 iterations.
After mapping 4 to 3, we are thus given a number between 1 and 3, as described in the postcondition.

Unfortunately, the verifier cannot deduce this fact since the postcondition of \ttt{collatzIterations} only guarantees positive result, but no specific range of values.
Again, we can resort to dynamic methods to aid verification:

\begin{lstlisting}
...
{
    int result = collatzIterations(300, seed);
    // we know:        result $\in$ { 1, 2, 4 }
    // verifier knows: 1 <= result
    
    // knowledge "cast"
    if (!(result <= 4))
        throw new IllegalStateException("expected result <= 4");

    // verifier knows: 1 <= result && result <= 4 
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}

This solution is not satisfying as it required additional work by the programmer to convince the verifier.
Furthermore, the solution is in an unintuitive location:
The problem is not caused by \ttt{myRandom}, yet it is solved there.
The actual problem is that the postcondition of \ttt{collatzIterations} is too weak, causing the verifier to fail deducing our knowledge.

Gradual verification allows enhancing the postcondition with “unknown” knowledge that can be reinterpreted arbitrarily, adding appropriate runtime checks to guarantee that this reinterpretation was in fact valid:
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 1 <= start;
    ensures  1 <= result && ?;
{
    // ...
}

int myRandom(int seed)
    requires 1 <= seed   && seed   <= 10000;
    ensures  1 <= result && result <= 3;
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    // verifier allowed to
    //  assume 1 <= start && result <= 4
    //  from   1 <= start && ?
    // (adding runtime check)
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}
Note the \ttt{?} in the postcondition of \ttt{collatzIterations}.

% gradual:
% - not in a sense of GraVy
% - assertions are GUARANTEED not to be violated (analogous to type safety of gradually typed languages), meaning that
%    - as much as possible is verified statically
%    - if necessary, (ideally: as few as possible) dynamic checks kick in
% - full continuum between static and dynamic

% static checking
% dynamic checking
% combine static and dynamic checking
% views:
% - add designated "?" to statically checked language, making checking optional
% - introduce checking to unchecked language, making "?" the default value
% typing
% transition to verification
% - of particular interest, cause limitations due to syntax or decidability make full checking impossible,
%    possibly making use of static verification impossible and the program thus unverifiable
%    inevitable incompleteness of static verifiers!
%    GraVy: measure, only \textit{classifies} code into sections: correctness statically guaranteed, correctness statically disproved, no static guarantee so far

% very desirable in practice
% gradual version of a language is inherently a strict superset of original language
% 

% our approach allows extension of existing languages (without any verification) by adding transpilation step

% why would you want continuum?
% - move toward satically verified program without giving up guarantees!
% - while "barely typed" languages hardly make sense, programs with "little verification" are already highly useful
%    i.e. verification even makes sense as "rarely used feature"!
%    ArgumentException-example
%    -    performance benefit!
%    -    cleaner code!
%    -    makes more sense semantically
% having optional types 

% Future Work:
% implement on top of existing languages
% - tracking access via ThreadLocalStorage
% - transpilation (e.g. C# Roslyn compiler extension)