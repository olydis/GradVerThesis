
\subsection{Argument Validation}
The following Java example motivates the use of verification for argument validation.
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    // business logic:
    resAllocate();
    boolean result = c.driver.age >= 18;
    resFree();
    return result;
}
\end{lstlisting}
A call to \ttt{hasLegalDriver} fails if \ttt{c} or \ttt{c.driver} evaluate to \ttt{null}.
Note that, although the Java runtime has defined behavior in to those cases (throwing an exception), we might still have created a resource leak.
To prevent this from happening, arguments have to be validated before entering the business logic.
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    if (!(c != null))
        throw new IllegalArgException("expected c != null");
    if (!(c.driver != null))
        throw new IllegalArgException("expected c.driver != null");
        
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

Note that these runtime checks dynamically verifies a method contract, having \ttt{c != null \&\& c.driver != null} as precondition.
Naturally, the drawbacks of dynamic verification apply:
Violations of the method contract are only detected at runtime, possibly go unnoticed for a long time and impose a runtime overhead which might not be acceptable in all scenarios.
Java even has dedicated assertion syntax simplifying dynamic verification:
\begin{lstlisting}
boolean hasLegalDriver(Car c)
{
    assert c != null;
    assert c.driver != null;

    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}
Note however that such assertions are dropped from regular builds, meaning that the method contract is no longer verified!

With support of additional tools, a more declarative approach is possible using JML syntax:
\begin{lstlisting}
//@ requires c != null && c.driver != null;
boolean hasLegalDriver(Car c)
{
    // business logic (requires 'c.driver.age' to evaluate)
}
\end{lstlisting}

There are two basic ways to turn this annotation into a guarantee:
\begin{description}
    \item[Static Verification (e.g. ESC/Java, see \cite{leino2000esc})]~\\
    Verification will only succeed if the precondition is provable at all call sites.
    This is achievable in two ways:
    \begin{itemize}
        \item
        Rigorously annotate the call sites, guiding the verifier towards a proof.
        \item 
        Add parameter validation to the call sites, effectively duplicating the original runtime check across the program.
        Note that this approach combines static and dynamic validation in order to get a performance benefit (no more runtime checks required where precondition was provable) and circumvent rigorous annotation.
        The drawback is of course code duplication.
    \end{itemize}
    % benefits, drawbacks
    
    %There are obvious limitations to this approach, static verification tends to be invasive.
    %At least there is a performance benefit: 
    %Runtime checks (originally part of every call) are now only necessary in places where verification would not succeed otherwise.
    
    \item[Dynamic Verification (e.g. run JML4c, see \cite{sarcar2010new}]~\\
    This approach basically converts the annotation back into a runtime check equivalent to our original argument validation.
    % benefits, drawbacks
\end{description}

Gradual verification would pursue the combined approach without (visible) code duplication:
Static verification is used where possible, dynamic verification where needed.
Note that for the programmer this means that adding the method contract comes with no further obligations.

\subsection{Limitations of Static Verification}
The following example is written in a Java-like language with dedicated syntax for method contracts (similar to Eiffel and Spec\#).
We assume that this language is statically verified, i.e. static verification is part of the compilation.

The example shows the limitations of static verification using the Collatz sequence as an algorithm too complex to describe concisely in a method contract:
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 1 <= start;
    ensures  1 <= result;
{
    // ...
}

int myRandom(int seed)
    requires 1 <= seed   && seed   <= 10000;
    ensures  1 <= result && result <= 3;     // not provable
{
    int result = collatzIterations(300, seed);
    // we know:        result $\in$ { 1, 2, 4 }
    // verifier knows: 1 <= result
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}
The first method \ttt{collatzIterations} iterates given number of times, starting at given value.
We assume that the only provable contract is that positive start value results in positive result.
The second method \ttt{myRandom} uses the Collatz sequence to generate a pseudo random number from given seed.
It is known to the programmer that start values up to 10000 result in convergence of the sequence after 300 iterations.
After mapping 4 to 3, we are thus given a number between 1 and 3, as described in the postcondition.

Unfortunately, the verifier cannot deduce this fact since the postcondition of \ttt{collatzIterations} only guarantees positive result, but no specific range of values.
Again, we can resort to dynamic methods to aid verification:

\begin{lstlisting}
...
{
    int result = collatzIterations(300, seed);
    // we know:        result $\in$ { 1, 2, 4 }
    // verifier knows: 1 <= result
    
    // knowledge "cast"
    if (!(result <= 4))
        throw new IllegalStateException("expected result <= 4");

    // verifier knows: 1 <= result && result <= 4 
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}

This solution is not satisfying as it required additional work by the programmer to convince the verifier.
Furthermore, the solution is in an unintuitive location:
The problem is not caused by \ttt{myRandom}, yet it is solved there.
The actual problem is that the postcondition of \ttt{collatzIterations} is too weak, causing the verifier to fail deducing our knowledge.

Gradual verification allows enhancing the postcondition with “unknown” knowledge that can be reinterpreted arbitrarily, adding appropriate runtime checks to guarantee that this reinterpretation was in fact valid:
\begin{lstlisting}
int collatzIterations(int iter, int start)
    requires 1 <= start;
    ensures  1 <= result && ?;
{
    // ...
}

int myRandom(int seed)
    requires 1 <= seed   && seed   <= 10000;
    ensures  1 <= result && result <= 3;
{
    int result = collatzIterations(300, seed);
    // we know: result $\in$ { 1, 2, 4 }
    
    // verifier allowed to
    //  assume 1 <= start && result <= 4
    //  from   1 <= start && ?
    // (adding runtime check)
    
    if (result == 4) result = 3;
    return result;
}
\end{lstlisting}
Note the \ttt{?} in the postcondition of \ttt{collatzIterations}.

% gradual:
% - not in a sense of GraVy
% - assertions are GUARANTEED not to be violated (analogous to type safety of gradually typed languages), meaning that
%    - as much as possible is verified statically
%    - if necessary, (ideally: as few as possible) dynamic checks kick in
% - full continuum between static and dynamic

% static checking
% dynamic checking
% combine static and dynamic checking
% views:
% - add designated "?" to statically checked language, making checking optional
% - introduce checking to unchecked language, making "?" the default value
% typing
% transition to verification
% - of particular interest, cause limitations due to syntax or decidability make full checking impossible,
%    possibly making use of static verification impossible and the program thus unverifiable
%    inevitable incompleteness of static verifiers!
%    GraVy: measure, only \textit{classifies} code into sections: correctness statically guaranteed, correctness statically disproved, no static guarantee so far

% very desirable in practice
% gradual version of a language is inherently a strict superset of original language
% 

% our approach allows extension of existing languages (without any verification) by adding transpilation step

% why would you want continuum?
% - move toward satically verified program without giving up guarantees!
% - while "barely typed" languages hardly make sense, programs with "little verification" are already highly useful
%    i.e. verification even makes sense as "rarely used feature"!
%    ArgumentException-example
%    -    performance benefit!
%    -    cleaner code!
%    -    makes more sense semantically
% having optional types 

% Future Work:
% implement on top of existing languages
% - tracking access via ThreadLocalStorage
% - transpilation (e.g. C# Roslyn compiler extension)