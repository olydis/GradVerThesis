Let ~$\sssem' : \setProgramState \rightharpoonup \setProgramState$~ be defined such that
\begin{flalign*}
\sssem'^s(\pi_1, \pi_2) ~\defiff~ \sssem^s(\pi_1, \pi_2) ~\wedge~ \exists \phi_1, \phi_2 \in \setFormula.~ \thoare{}{\phi_1}{s}{\phi_2} \wedge \evalphiGen{\pi_1}{\phi_1} \wedge \evalphiGen{\pi_2}{\phi_2}
\end{flalign*}
Intuitively, $\sssem'$ is the same as $\sssem$, but is artificially made undefined whenever there exists no Hoare rule that would be able to deduce static information about the execution.

\begin{lemma}[Restricted Domain of Small-Step Semantics]
    Replacing the small-step semantics $\sssem$ of \svl with $\sssem'$ as defined above would have no observable effects.
\end{lemma}

Let ~$\gsssem : \setGProgramState \rightarrow \setGProgramState$ be a total gradual lifting of $\sssem'$ that throws exceptions whenever all static derivations would be stuck:
\begin{displaymath}
\forall \grad{\pi} \in \setGProgramState.~ (\gamma(\grad{\pi}) \cap \dom{\sssem'} = \emptyset) \implies \gsssem(\grad{\pi}) \in \setProgramStateEx
\end{displaymath}

\begin{theorem}[]
    If the gradual small-step semantics $\gsssem$ of \gvl is defined as above, then \gvl satisfies \tset{GDPreservation}.
\end{theorem}
 
\begin{comment} 
MINUS:
- need above knowledge...
- not always desirable
    \begin{verbatim}
    {i = 10000}
    n = collatzIterations(300, i);
    {1 <= n * n <= 4}
    {n = 4}
    staticAssert (n = 4);
    {n = 4}
    \end{verbatim}
    would throw exception

Proof:
\begin{description}
    \item $\grad{s} \in \setGStmt$
    \item $\grad{\phi_1}, \grad{\phi_2} \in \setGFormula$
    \item $\grad{\pi_1}, \grad{\pi_2} \,\in \setGProgramState$
    \item[1 = Premise] $\dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}$
    \item[2 = HoareIntrosA] $\gsssem^{\grad{s}}(\grad{\pi_1}, \grad{\pi_2})$
    \item[3 = HoareIntrosB] $\evalgphiGen{\grad{\pi_1}}{\grad{\phi_1}}$
    \item[4 = Case] $\exists \pi_s \in \gamma(\grad{\pi_1}).~ \pi_s \in \wsp(s)$
    \item[5 = 4 + wsp def] $\exists \phi_1', \phi' \in \setFormula.~ \evalphiGen{\pi_s}{\phi_1'} ~\wedge \thoare{~}{\phi_1'}{s}{\phi'}$
    \item[6 = 4 + 5 + rule42] $\exists \phi_1 \in \gamma(\grad{\phi_1}).~ \phiImplies{\phi_1}{\phi_1'} \wedge \evalphiGen{\pi_s}{\phi_1}$
    \item[7 = 5 + 6 + mono] $\exists \phi \in \setFormula.~ \thoare{~}{\phi_1}{s}{\phi}$
    \item[8 = 7 + intro] $\exists \grad{\phi} \in \setGFormula.~ \dgthoare{~}{\phi_1}{s}{\grad{\phi}}$
    \item[9 = 1 + 6 + 8 + mono_det_hoare] $\grad{\phi} \sqsubseteq \grad{\phi_2}$
    \item[10 = 8 + pres] $\exists \phi_2 \in \gamma(\grad{\phi}).~ \thoare{~}{\phi_1}{s}{\phi_2}$
    \item[11 = 6 + 10 + snd] $\evalphiGen{\sssem^s(\pi_s)}{\phi_2}$
    \item[12 = 11 + intro] $\evalphiGen{\gsssem^s(\pi_s)}{\phi_2}$
    \item[13 = 3 + 12 + mono] $\evalphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\phi_2}$
    \item[14 = 13 + intro] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\phi_2}$
    \item[15 = 10 + 14 + mono] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\grad{\phi}}$
    \item[16 = 9 + 15 + mono] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\grad{\phi_2}}$
\end{description}


\begin{description}
    \item $\grad{s} \in \setGStmt$
    \item $\grad{\phi_1}, \grad{\phi_2} \in \setGFormula$
    \item $\grad{\pi_{\grad{s}}} \,\in \setGProgramState_{\grad{s}}$
    \item[1 = PremiseA] $\dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}$
    \item[2 = PremiseB] $\evalgphiGen{\grad{\pi_{\grad{s}}}}{\grad{\phi_1}}$
    \item[3 = Case] $\neg \exists \pi_s \in \gamma(\grad{\pi_{\grad{s}}}).~ \pi_s \in \wsp(s)$
    \item[4 = 3 + completeness] $\forall \pi_s \in \gamma(\grad{\pi_{\grad{s}}}).~ \sssem^s(\pi_s) \textit{ stuck}$
    \item[5 = 4 + def] $\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}}) = \pi_{EX}$
    \item[6 = 5 + precision] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\grad{\phi_2}}$
\end{description}

\end{comment}
