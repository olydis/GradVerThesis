
Choose ~$\gsssem : \setGProgramState \rightarrow \setGProgramState$~ as lifted version of ~$\sssem : \setProgramState \rightharpoonup \setProgramState$ with $\gsssem(\grad{\pi}) = \pi_{EX}$ if stuck for all concretizations.

\begin{align*}
\wsp : \setGStmt \rightarrow \setProgramState \\
\wsp(\grad{s}) ~\defeq~ \bigcup_{s \in \gamma_s(\grad{s})} \wsp(s)
\end{align*}

\begin{align*}
\forall \grad{s} \in \setGStmt.~&\\ 
\grad{\pi_{\grad{s}}} \in \setGProgramState_{\grad{s}}.~& \wsp(\grad{s}) \cap \gamma_{\pi}(\grad{\pi_{\grad{s}}}) = \emptyset
\implies
\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}}) = \pi_{EX}
\end{align*}
 
 
MINUS:
- need above knowledge...
- not always desirable
    \begin{verbatim}
    {i = 10000}
    n = collatzIterations(300, i);
    {1 <= n * n <= 4}
    {n = 4}
    staticAssert (n = 4);
    {n = 4}
    \end{verbatim}
    would throw exception!?
    
Proof:
\begin{description}
    \item $\grad{s} \in \setGStmt$
    \item $\grad{\phi_1}, \grad{\phi_2} \in \setGFormula$
    \item $\grad{\pi_1}, \grad{\pi_2} \,\in \setGProgramState$
    \item[1 = Premise] $\dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}$
    \item[2 = HoareIntrosA] $\gsssem^{\grad{s}}(\grad{\pi_1}, \grad{\pi_2})$
    \item[3 = HoareIntrosB] $\evalgphiGen{\grad{\pi_1}}{\grad{\phi_1}}$
    \item[4 = Case] $\exists \pi_s \in \gamma(\grad{\pi_1}).~ \pi_s \in \wsp(s)$
    \item[5 = 4 + wsp def] $\exists \phi_1', \phi' \in \setFormula.~ \evalphiGen{\pi_s}{\phi_1'} ~\wedge \thoare{~}{\phi_1'}{s}{\phi'}$
    \item[6 = 4 + 5 + rule42] $\exists \phi_1 \in \gamma(\grad{\phi_1}).~ \phiImplies{\phi_1}{\phi_1'} \wedge \evalphiGen{\pi_s}{\phi_1}$
    \item[7 = 5 + 6 + mono] $\exists \phi \in \setFormula.~ \thoare{~}{\phi_1}{s}{\phi}$
    \item[8 = 7 + intro] $\exists \grad{\phi} \in \setGFormula.~ \dgthoare{~}{\phi_1}{s}{\grad{\phi}}$
    \item[9 = 1 + 6 + 8 + mono_det_hoare] $\grad{\phi} \sqsubseteq \grad{\phi_2}$
    \item[10 = 8 + pres] $\exists \phi_2 \in \gamma(\grad{\phi}).~ \thoare{~}{\phi_1}{s}{\phi_2}$
    \item[11 = 6 + 10 + snd] $\evalphiGen{\sssem^s(\pi_s)}{\phi_2}$
    \item[12 = 11 + intro] $\evalphiGen{\gsssem^s(\pi_s)}{\phi_2}$
    \item[13 = 3 + 12 + mono] $\evalphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\phi_2}$
    \item[14 = 13 + intro] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\phi_2}$
    \item[15 = 10 + 14 + mono] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\grad{\phi}}$
    \item[16 = 9 + 15 + mono] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\grad{\phi_2}}$
\end{description}


\begin{description}
    \item $\grad{s} \in \setGStmt$
    \item $\grad{\phi_1}, \grad{\phi_2} \in \setGFormula$
    \item $\grad{\pi_{\grad{s}}} \,\in \setGProgramState_{\grad{s}}$
    \item[1 = PremiseA] $\dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}$
    \item[2 = PremiseB] $\evalgphiGen{\grad{\pi_{\grad{s}}}}{\grad{\phi_1}}$
    \item[3 = Case] $\neg \exists \pi_s \in \gamma(\grad{\pi_{\grad{s}}}).~ \pi_s \in \wsp(s)$
    \item[4 = 3 + completeness] $\forall \pi_s \in \gamma(\grad{\pi_{\grad{s}}}).~ \sssem^s(\pi_s) \textit{ stuck}$
    \item[5 = 4 + def] $\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}}) = \pi_{EX}$
    \item[6 = 5 + precision] $\evalgphiGen{\gsssem^{\grad{s}}(\grad{\pi_{\grad{s}}})}{\grad{\phi_2}}$
\end{description}