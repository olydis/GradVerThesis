% TODO

\begin{figure}[h]
    \input{data/svl-syntax}
    \caption{\svlidf: Syntax}
    \label{fig:idf-syntax}
\end{figure}

We pose $\phiFalse \defeq \phiNeq{\enull}{\enull}$.
We define $\ttt{;}$ to be right-associative and assume that parsing a sequence of statements (e.g. method body) operates analogously, obviating the need for parenthesis.
Furthermore we assume that the parser terminates every sequence with $\sSkip$.
\begin{exmp}~
    \begin{lstlisting}
    ...
    {
        $s_1$;
        $s_2$;
        $s_3$;
    }
    \end{lstlisting}
    is parsed as
    
    \includegraphics[trim={3cm 3cm 3cm 3cm}, clip, width=6cm]{graphics/rightAssocSkip}
\end{exmp}
These assumptions highly simplify reasoning about statements.

For future reference, we give further (non-syntactic) definitions:
\begin{figure}[h]
    \begin{align*}
    A_s    & \in \setSFootprint &  & =~~ \PP^{\setExpr \times \setFieldName}                                                    \\
    A_d    & \in \setDFootprint &  & =~~ \PP^{\setLoc \times \setFieldName}                                                     \\
    \Gamma & \in \setTypeEnv    &  & =~~ \setVar \rightharpoonup \setType                                                       \\
    \rho   & \in \setVarEnv     &  & =~~ \setVar \rightharpoonup \setVal                                                        \\
    E      & \in \setStackEntry &  & =~~ \setVarEnv \times \setDFootprint \times \setStmt                                       \\
    S      & \in \setStack      &  & ::= E \cdot S ~|~ \nil                                                                     \\
    H      & \in \setHeap       &  & =~~ \setLoc \rightharpoonup (\setClassName \times (\setFieldName \rightharpoonup \setVal))
    \end{align*}
    \caption{\svlidf: Further Definitions}
\end{figure}



% Programs consist of classes and a main method, represented directly as the list of its instructions.
% TODO: introduce all the extraction predicates/functions!
