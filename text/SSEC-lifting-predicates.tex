
% TODO: we dissect the gradual lifting notion of AGT
In this section, we assume that we are dealing with a binary predicate $P \subseteq \setFormula \times \setFormula$.
The concepts are directly applicable to predicates with different arity or with additional non-formula parameters.
The lifted version we are targeting has signature $\grad{P} \subseteq \setGFormula \times \setGFormula$.
W.l.o.g. we further assume that $P$ appears unnegated in the axiomatic semantics (otherwise we simply regard the negation of that predicate as $P$).

Rules emerging from the gradual guarantee:
\begin{description}
    \item[Introduction]~\\
    Having source code that is considered valid by the static verification system, the same source code must be considered valid by the gradual verification system.
    In other words, switching to the gradual system may never “break the code”.
    This means that arguments satisfying $P$ must satisfy $\grad{P}$:
    \begin{mathpar}
        \inferrule* [Right=GPredIntro]
        {
            P(\phi_1, \phi_2)
        }
        {
            \grad{P}(\phi_1, \phi_2)
        }
    \end{mathpar}
    
    Or equivalently, using set notation
    \begin{displaymath}
    P \subseteq \grad{P}
    \end{displaymath}
    
    \item[Monotonicity]~\\
    A central point of a gradual verification system is enabling programmers to specify contracts with less precision.
    Source code that is rejected by the verifier might get accepted after reducing precision.
    If the opposite would happen, though, that would be highly counter-intuitive and ...??? workflow.
    To prevent such behavior, we expect satisfied predicates to still be satisfied after reducing the precision of arguments:
    
    \begin{mathpar}
        \inferrule* [Right=GPredMon]
        {
            \grad{P}(\grad{\phi_1}, \grad{\phi_2}) \\
            \grad{\phi_1} \sqsubseteq \grad{\phi_1'} \\
            \grad{\phi_2} \sqsubseteq \grad{\phi_2'}
        }
        {
            \grad{P}(\grad{\phi_1'}, \grad{\phi_2'})
        }
    \end{mathpar}
    
    or equivalently, thinking of predicates as boolean functions
    \begin{displaymath}
    \grad{P}  \text{ is monotonic w.r.t. $\sqsubseteq$}
    \end{displaymath}
    or something with set terminology!???
    \begin{displaymath}
    \grad{P}  \text{ is somewhat closed over weakening}
    \end{displaymath}
\end{description}

\begin{definition}[Valid/Sound??? Predicate Lifting]
    A lifted predicate is called \textbf{sound/valid} if it is closed under the above rules.
\end{definition}

Note that $\grad{P} = \setGFormula \times \setGFormula$ is a sound predicate lifting of any binary predicate $P \subseteq \times \setFormula$.
% Apparently satisfying the gradual guarantee only gives a lower bound to lifted predicates.

\begin{definition}[Consistent/Optimal??? Predicate Lifting]
    A lifted predicate is called \textbf{consistent/optimal} if it is the smallest set closed under the above rules.
\end{definition}

This definition coincides with the definition of consistent predicate lifting in AGT:

\begin{lemma}[Consistent Predicate Lifting (Direct Definition)]\label{lemma:consistent-pred-lifting-direct}
    Let $\grad{P} \subseteq \setGFormula \times \setGFormula$ be defined as
    \begin{displaymath} 
    \grad{P}(\grad{\phi_1}, \grad{\phi_2}) ~\defiff~ \exists \phi_1 \in \gamma(\grad{\phi_1}), \phi_2 \in \gamma(\grad{\phi_2}).~ P(\phi_1, \phi_2)
    \end{displaymath}
    $\grad{P}$ is the only consistent lifting of $P$.
\end{lemma} %PROOF

% delve more into what is important, what is optional, etc.?

% For sound rules this holds:
% \begin{displaymath}
% \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula.~ (\exists \phi_1 \in \gamma(\grad{\phi_1}), \phi_2 \in \gamma(\grad{\phi_2}).~ P(\phi_1, \phi_2)) \implies \grad{P}(\grad{\phi_1}, \grad{\phi_2})
% \end{displaymath}

\textbf{Consistent lifting of common predicates:}

%% evalphi
\begin{lemma}[Consistent Lifting of Evaluation]~\\
    Let $~~\evalgphiGen{\cdot}{\cdot}~ \subseteq \setProgramState \times \setGFormula$ be defined as
    \begin{displaymath} 
    \evalgphiGen {\pi} {\grad{\phi}} ~\defiff~ \exists \phi \in \gamma(\grad{\phi}).~ \evalphiGen {\pi} {\phi}
    \end{displaymath}
    Then $~\evalgphiGen{\cdot}{\cdot}~$ is a consistent lifting of $~\evalphiGen{\cdot}{\cdot}~$.
\end{lemma}

Note that above definition can be further simplified if concretization is defined as in section \ref{sec:gradual-formulas}:
\begin{displaymath} 
\evalgphiGen {\pi} {\grad{\phi}} ~\iff~ \evalphiGen {\pi} {\static(\phi)} 
\end{displaymath}

%% phiImplies
\begin{lemma}[Consistent Lifting of Evaluation]~\\
    Let $~~\gphiImplies{\cdot}{\cdot}~ \subseteq \setGFormula \times \setGFormula$ be defined as
    \begin{displaymath} 
    \gphiImplies {\grad{\phi_1}} {\grad{\phi_2}} ~\defiff~ \exists \phi_1 \in \gamma(\grad{\phi_1}), \phi_2 \in \gamma(\grad{\phi_2}).~ \phiImplies {\phi_1} {\phi_2}
    \end{displaymath}
    Then $~\gphiImplies{\cdot}{\cdot}~$ is a consistent lifting of $~\phiImplies{\cdot}{\cdot}~$.
\end{lemma}


% TODO examples: evaluation and implication (at least)

