% It is one of our design goals to make any program of the static system a valid program of the 
% the resulting gradual system compatible with the old one (otherwise it would trivially not  satisfy the gradual guarantee \ref{grad-guarantee}).

We introduce the concepts of gradual verification by introducing a wildcard formula $\qm$ into the formula syntax, resulting in a new set of gradual formulas $\setGFormula$.
There are different ways to introduce the wildcard, we will describe two common options in the following sections.

%% COMMON KNOWLEDGE
Note that we want to strictly extend the existing formula syntax in order to maintain compatibility with the static system, i.e. $\setFormula \subset \setGFormula$ holds.
This design goal ensures that any program considered syntactically valid by the static system will still be syntactically valid in the gradual system (motivated by gradual guarantee \ref{grad-guarantee}).

We decorate formulas $\grad{\phi} \in \setGFormula$ to distinguish them from formulas drawn from $\setFormula$.
Using the concept of abstract interpretation, we want to reason about gradual formulas by mapping them back to a set of satisfiable static formulas (called “concretization”) and then applying static reasoning to that set.
Intuitively, a program state satisfies a gradual formula iff it satisfies (at least) on of the static formulas of the its concretization.
(This intuition is formalized in section \ref{ssec:lifting-predicates}.)

% An example of that approach ... in section \ref{sec:lifting-predicates-and}

Without knowing specifics of the syntax extension, we can already formalize this approach for static formulas:
\begin{definition}[Concretization]~\\
    Let $\gamma : \setGFormula \rightarrow \PP(\setFormulaA)$ be defined as follows:
    \begin{align*}
    &\gamma(\phi) = 
        \begin{cases}
        \{~ \phi ~\}  & \phi \in \setFormulaA\\
        \emptyset     & \textit{otherwise}
        \end{cases}\\
    &\gamma(\grad{\phi}) = \textit{to be defined when extending the syntax}     \quad\quad \forall \phi \in \setGFormula\\
    \end{align*}
\end{definition}

% more detail about singleton mapping and why it makes sense?