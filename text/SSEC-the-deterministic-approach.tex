% proof by example: optimal deterministic lifting does not induce optimal predicate lifting!
% not verifiable with consistent predicate
% { ? }
% release acc(x.f)
% { ? * acc(x.f) }
%
% but
% { ? }
% release acc(x.f)
% { ? }
% =>
% { ? * acc(x.f) }
%
%
% not verifiable with consistent predicate
% { ? }
% x := random();
% { (x = 0) }
%
% but
% { ? }
% x := random();
% { ? }
% =>
% { (x = 0) }

%% intro
In the previous section we built an intuition about intermediate gradual formulas that are neither too weak (increasing the chance of hiding inconsistencies) not too strict (making assumptions that are neither general nor required by the following judgment and thus alter runtime behavior).
While this problem could certainly be solved by designing a sophisticated inference algorithm for gradual formulas, we propose solving the problem at the level of the gradual Hoare logic.
In this section we define a deterministic gradual Hoare logic $\dgthoare{}{\cdot}{\cdot}{\cdot} : \setGFormula \times \setGStmt \rightharpoonup \setGFormula$ which has very desirable properties and fits well into our existing model, as described later.

~\\
%% approach idea
Our approach is based on the idea to treat the Hoare predicate as a (multivalued) function, mapping preconditions to the set of possible/verifiable postconditions.
From this multivalued function we can obtain a lifted version, following similar rules to the ones for lifted partial functions (see \ref{sssec:lifting-partial-functions}).

%% def
Given a binary predicate $P \subseteq \setFormula \times \setFormula$ we call a partial function $\dgrad{P} : \setFormula \rightharpoonup \setFormula$ \textbf{deterministic lifting} of $P$ if the following conditions are met.
As before, the same rules can easily be adapted to different parameter types and higher arity.
\begin{description}
    \item[Introduction]~\\
    The deterministic lifting should be defined whenever the underlying predicate is.
    \begin{displaymath}
    \forall (\phi_1, \phi_2) \in P.~ \phi_1 \in \dom(\dgrad{P})
    \end{displaymath}
    
    \item[Strength]~\\
    A return value of the deterministic lifting should agree with all instantiations of the underlying predicate.
    \begin{mathpar}
        \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula.~ 
        \dgrad{P}(\grad{\phi_1}) = \grad{\phi_2}\\
        \implies\\
        \forall \phi_1 \in \gamma(\grad{\phi_1}), \phi \in \setFormula.~ P(\phi_1, \phi) \implies \exists \phi_2 \in \gamma(\grad{\phi_2}).~ P(\phi_1, \phi_2) ~\wedge~ \phiImplies{\phi_2}{\phi}
    \end{mathpar}
    
    For Hoare rules this means that the postcondition returned must be at least as strong as every postcondition returned by static Hoare logic (it might be less precise, though).
    The following example illustrates the effects of the rule:
    Assume that the following list contains all instantiations of $\thoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\cdot}$.
    \begin{flalign*}
    \thoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{2}{2}}\\
    \thoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{x}{2}}\\
    \thoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{2}{x}}\\
    \thoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{x}{x}}
    \end{flalign*}
    Then valid return values for the deterministic lifting are
    \begin{flalign*}
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{x}{2}}\\
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{2}{x}}\\
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\qm}\\
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\withqmGen{\phiEq{x}{2}}}\\
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\withqmGen{\phiEq{2}{x}}}
    \end{flalign*}
    Not valid are weaker static values like
    \begin{flalign*}
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{2}{2}}\\
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiEq{x}{x}}
    \end{flalign*}
    or stronger values like
    \begin{flalign*}
    &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{x}{2}}{\phiAnd{\phiEq{y}{3}}{\phiEq{x}{2}}}
    \end{flalign*}
    
    \item[Monotonicity]~\\
    Identical to monotonicity condition of lifted partial functions (see section \ref{sssec:lifting-partial-functions}). % say why? P/f doesn't show up.
    \begin{displaymath}
    \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula.~ \grad{\phi_1} \sqsubseteq \grad{\phi_2} \wedge \grad{\phi_1} \in \dom(\dgrad{P}) \implies \dgrad{P}(\grad{\phi_1}) \sqsubseteq \dgrad{P}(\grad{\phi_2})
    \end{displaymath}
\end{description}

Soundness and optimality are defined as usual (see sections \ref{ssec:lifting-predicates} or \ref{text/SSEC-lifting-functions}).

%% application & properties
Assume we have obtained the deterministic lifting $\dgthoare {~} {\cdot} {\cdot} {\cdot}$ of our Hoare logic.
This gradual partial function has desirable properties:
\begin{description}
    \item[(a) Obtaining a Sound Gradual Lifting]
    \begin{lemma}[Deterministic Lifting as Sound Lifting]~\\
        \label{lem:det2grad}
        Let $\dgrad{P}$ be a deterministic lifting of $P$.
        Then
        \begin{displaymath}
        \grad{P}(\grad{\phi_1}, \grad{\phi_2}) ~~\defiff~~ \exists \grad{\phi_2'}.~ \dgrad{P}(\grad{\phi_1}) = \grad{\phi_2'} \wedge \gphiImplies {\grad{\phi_2'}} {\grad{\phi_2}}
        \end{displaymath}
        is a sound gradual lifting of $P$.
    \end{lemma}
    
    This observation bridges the gap between $\dgthoare {~} {\cdot} {\cdot} {\cdot}$ and the gradual verifier which is supposed to implement $\gthoare {~} {\cdot} {\cdot} {\cdot}$.
    Optimality of the deterministic lifting does not imply optimality of the obtained gradual lifting.
    
    \item[(b) Determinism of Verifier]~\\
    As the name suggests, deterministic liftings leave no room for choice.
    For the gradual verifier this means that there is no need to infer intermediate formulas, averting the risk of choosing the wrong formulas (as illustrated in section \ref{ssec:the-problem-with}).
    
    \item[(c) Free Transitivity]~\\
    Furthermore, applying Hoare rules transitively induces no more additional runtime cost:
    As described in \ref{ssec:gradual-soundness}, every judgment of the form $\gthoare {~} {\cdot} {\cdot} {\cdot}$ must be accompanied with the injection of a runtime check in order to guarantee preservation.
    Note that applying gradual Hoare logic to a sequence of statements (using GHSec) requires such judgment for every single statement, resulting in assertions between every pair of statements.
    
    Using a deterministic lifting transitively induces no such runtime cost since the no judgment of the form $\gthoare {~} {\cdot} {\cdot} {\cdot}$ is made.
    Only after applying lemma \ref{lem:det2grad} in the very end of verification, an assertion will be injected to ensure preservation for the overall judgment.
    
    \item[(d) Preservation]~\\
    Deterministic liftings are designed in a way that enables defining a stronger notion of preservation that does not rely on runtime assertions.
    \begin{mathpar}
        \inferrule* [Right=GDPreservation]
        {
            \dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
        }
        {
            \gtHoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
        }
    \end{mathpar}
    Note however, that this rule is not automatically satisfied, this also depends on the gradual dynamic semantics of \gvl.
    
    Example:
    Assume that \svl contains an assertion statement with corresponding Hoare rule.
    \begin{mathpar}
        \inferrule* [Right=HAssert]
        {
            \phiImplies{\phi}{\phi_a}
        }
        {
            \thoare{~}{\phi}{\sAssert{$\phi_a$}}{\phi}
        }
    \end{mathpar}
    Soundness of the Hoare logic implies that assertions are guaranteed to hold at runtime.
    It is therefore reasonable for \svl to implement assertions as no-operations.
    
    A valid deterministic lifting of \tset{HAssert} is able to verify
    \begin{displaymath}
    \dgthoare{~}{\qm}{\sAssert{$\phi_a$}}{\withqmGen{\phi_a}}
    \end{displaymath}
    However, if the gradual dynamic semantics of \gvl still implement assertions as a no-operation, then $\gtHoare{}{\qm}{\sAssert{$\phi_a$}}{\withqmGen{\phi_a}}$ does not hold.
    On the other hand, adding a runtime check that throws an exception on failure would restore preservation.
\end{description}