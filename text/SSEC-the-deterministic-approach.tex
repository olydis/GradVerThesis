% proof by example: optimal deterministic lifting does not induce optimal predicate lifting!
% not verifiable with consistent predicate
% { ? }
% release acc(x.f)
% { ? * acc(x.f) }
%
% but
% { ? }
% release acc(x.f)
% { ? }
% =>
% { ? * acc(x.f) }
%
%
% not verifiable with consistent predicate
% { ? }
% x := random();
% { (x = 0) }
%
% but
% { ? }
% x := random();
% { ? }
% =>
% { (x = 0) }

%% intro
In the previous section we built an intuition about intermediate gradual formulas that are neither too weak (increasing the chance of hiding inconsistencies) nor too strict (making assumptions that are neither general nor required by the following judgment and thus alter runtime behavior).
While this problem could certainly be solved by designing a sophisticated inference algorithm for gradual formulas, we propose solving the problem at the level of the gradual Hoare logic.
In this section we define a deterministic gradual Hoare logic $\dgrad{\vdash} : \setGFormula \times \setGStmt \rightharpoonup \setGFormula$ which has the following desirable properties (formalized later):
A gradual lifting $\gthoare{}{\cdot}{\cdot}{\cdot}$ can be obtained from $\dgthoare{}{\cdot}{\cdot}{\cdot}$, which is required for the gradual verifier.
This gradual lifting is not defined inductively and does rely on variables to be instantiated, hence making the verification process deterministic as well.
Furthermore $\dgrad{\vdash}$ allows for a stronger notion of soundness that does not rely on runtime checks.

We will use our familiar notation $\dgthoare{}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}$ as an alias for $~\dgrad{\vdash}(\grad{\phi_1}, \grad{s}) = \grad{\phi_2}$

~\\
%% approach idea
Our approach is based on the idea to treat the Hoare predicate as a (multivalued) function, mapping preconditions to the set of possible/verifiable postconditions.
From this multivalued function we can obtain a lifted version, following similar rules to the ones for lifted partial functions (see \ref{sssec:lifting-partial-functions}).

%% def
Given a binary predicate $P \subseteq \setFormula \times \setFormula$ we call a partial function $\dgrad{P} : \setFormula \rightharpoonup \setFormula$ \textbf{deterministic lifting} of $P$ if the following conditions are met.
As before, the rules can be adapted to different parameter types and higher arity.
We indicate an adaptation to Hoare logic in light gray using function notation for $\dgrad{\vdash}$.
\begin{description}
    \item[Introduction]~\\
    The deterministic lifting should be defined whenever the underlying predicate is.
    \begin{displaymath}
    \forall \langle \phi_1, \phi_2 \rangle \in P.~ \phi_1 \in \dom{\dgrad{P}}
    \end{displaymath}
    \textcolor{gray}{
        \begin{displaymath}
        \forall \langle \phi_1, s, \phi_2 \rangle \in \thoare{}{\cdot}{\cdot}{\cdot}.~ \langle \phi_1, s \rangle \in \dom{\dgrad{\vdash}}
        \end{displaymath}
    }
    
    \item[Strength]~\\
    A return value of the deterministic lifting should agree with all instantiations of the underlying predicate.
    \begin{mathpar}
        \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula.~ 
        \dgrad{P}(\grad{\phi_1}) = \grad{\phi_2}\\
        \implies\\
        \forall \phi_1 \in \gamma(\grad{\phi_1}),\, \phi \in \setFormula.~ P(\phi_1, \phi) \implies\\
        \exists \phi_2 \in \gamma(\grad{\phi_2}).~ P(\phi_1, \phi_2) ~\wedge~ (\phiImplies{\phi_2}{\phi})
    \end{mathpar}
    \textcolor{gray}{
        \begin{mathpar}
        \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula,\, \grad{s} \in \setGStmt.~ 
        \dgrad{\vdash}(\grad{\phi_1}, \grad{s}) = \grad{\phi_2}\\
        \implies\\
        \forall \phi_1 \in \gamma(\grad{\phi_1}),\, s \in \gamma(\grad{s}),\, \phi \in \setFormula.~ \thoare{}{\phi_1}{s}{\phi} \implies\\
        \exists \phi_2 \in \gamma(\grad{\phi_2}).~ \thoare{}{\phi_1}{s}{\phi_2} ~\wedge~ (\phiImplies{\phi_2}{\phi})
        \end{mathpar}
    }
    
    For Hoare rules this means that the postcondition returned must be at least as strong as every postcondition returned by static Hoare logic (it might be less precise, though).
    The following example illustrates the effects of the rule:
    \begin{example}{Deterministic Lifting Strength}
        Assume that the following list contains all instantiations of $\thoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\cdot}$.
        \begin{flalign*}
        \thoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{2}{2}}\\
        \thoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{y}{2}}\\
        \thoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{2}{y}}\\
        \thoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{y}{y}}
        \end{flalign*}
        Then valid return values for the deterministic lifting are
        \begin{flalign*}
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{y}{2}}\\
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{2}{y}}\\
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\qm}\\
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\withqmGen{\phiEq{y}{2}}}\\
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\withqmGen{\phiEq{2}{y}}}
        \end{flalign*}
        Not valid are weaker static values like
        \begin{flalign*}
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{2}{2}}\\
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiEq{y}{y}}
        \end{flalign*}
        or stronger values like
        \begin{flalign*}
        &\dgthoare{}{\phiEq{2}{2}}{\sVarAssign{y}{2}}{\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}
        \end{flalign*}
        
        Likewise, with precondition $\qm$ (motivated by case “too strict” in section \ref{ssec:the-problem-with}) valid return values include
        \begin{flalign*}
        &\dgthoare{}{\qm}{\sVarAssign{y}{2}}{\qm}\\
        &\dgthoare{}{\qm}{\sVarAssign{y}{2}}{\withqmGen{\phiEq{y}{2}}}
        \end{flalign*}
        bot not
        \begin{flalign*}
        &\dgthoare{}{\qm}{\sVarAssign{y}{2}}{\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}
        \end{flalign*}
    \end{example}
    
    \item[Monotonicity]~\\
    Identical to monotonicity condition of lifted partial functions (see section \ref{sssec:lifting-partial-functions}). % say why? P/f doesn't show up.
    \begin{displaymath}
    \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula.~ 
    \grad{\phi_1} \sqsubseteq \grad{\phi_2} ~~\wedge~~ \grad{\phi_1} \in \dom{\dgrad{P}} 
    \implies 
    \dgrad{P}(\grad{\phi_1}) \sqsubseteq \dgrad{P}(\grad{\phi_2})
    \end{displaymath}
    \textcolor{gray}{
        \begin{displaymath}
        \forall \grad{\phi_1}, \grad{\phi_2} \in \setGFormula,\, \grad{s_1}, \grad{s_2} \in \setGStmt.~ 
        \grad{\phi_1} \sqsubseteq \grad{\phi_2} ~~\wedge~~ \grad{s_1} \sqsubseteq \grad{s_2} ~~\wedge~~ \langle \grad{\phi_1}, \grad{s_1} \rangle \in \dom{\dgrad{\vdash}}
        \implies 
        \dgrad{\vdash}(\grad{\phi_1}, \grad{s_1}) \sqsubseteq \dgrad{\vdash}(\grad{\phi_2}, \grad{s_2})
        \end{displaymath}
    }
\end{description}

Soundness and optimality are defined as usual (see sections \ref{ssec:lifting-predicates} or \ref{ssec:lifting-functions}).

%% application & properties
Assume we have obtained the deterministic lifting $\dgthoare {~} {\cdot} {\cdot} {\cdot}$ of our Hoare logic.
This gradual partial function has desirable properties:
\begin{description}
    \item[(a) Obtaining a Sound Gradual Lifting]
    \begin{lemma}[Deterministic Lifting as Sound Lifting]~\\
        \label{lem:det2grad}
        Let $\dgrad{P}$ be a deterministic lifting of $P$.
        Then
        \begin{displaymath}
        \grad{P}(\grad{\phi_1}, \grad{\phi_2}) ~~\defiff~~ \exists \grad{\phi_2'}.~ \dgrad{P}(\grad{\phi_1}) = \grad{\phi_2'} \wedge \gphiImplies {\grad{\phi_2'}} {\grad{\phi_2}}
        \end{displaymath}
        is a sound gradual lifting of $P$.
    \end{lemma}
    \begin{proof}~\\
        Introduction
        \begin{align*}
        P(\phi_1, \phi_2)
        &\overset{Introduction}{~\quad\implies\quad~} \exists \grad{\phi_2}.~ \grad{P}(\phi_1) = \grad{\phi_2}\\
        &\overset{Strength}{~\quad\implies\quad~} \exists \grad{\phi_2}.~ \grad{P}(\phi_1) = \grad{\phi_2} ~\wedge~ \exists \phi \in \gamma(\grad{\phi_2}).~ P(\phi_1, \phi) \wedge \phiImplies{\phi}{\phi_2} \\
        &\overset{}{~\quad\implies\quad~} \exists \grad{\phi_2}.~ \grad{P}(\phi_1) = \grad{\phi_2} ~\wedge~ \exists \phi \in \gamma(\grad{\phi_2}).~ \phiImplies{\phi}{\phi_2} \\
        &\overset{}{~\quad\implies\quad~} \exists \grad{\phi_2}.~ \grad{P}(\phi_1) = \grad{\phi_2} ~\wedge~  \gphiImplies{\grad{\phi_2}}{\phi_2} \\
        &\overset{Def}{~\quad\implies\quad~} \grad{P}(\phi_1, \phi_2) \\
        \end{align*}
            
        Monotonicity
        \begin{align*}
        \grad{P}(\grad{\phi_1}, \grad{\phi_2}) ~\wedge~ \grad{\phi_1} \mpt \grad{\phi_1'} ~\wedge~ \grad{\phi_2} \mpt \grad{\phi_2'}
        &\overset{Def}{~\quad\implies\quad~} (\exists \grad{\phi}.~ \dgrad{P}(\grad{\phi_1}) = \grad{\phi} \wedge \gphiImplies {\grad{\phi}} {\grad{\phi_2}}) ~\wedge~ \grad{\phi_1} \mpt \grad{\phi_1'} ~\wedge~ \grad{\phi_2} \mpt \grad{\phi_2'}\\
        &\overset{Monotonicity}{~\quad\implies\quad~} (\exists \grad{\phi}, \grad{\phi'}.~ \dgrad{P}(\grad{\phi_1'}) = \grad{\phi'} \wedge \grad{\phi} \mpt \grad{\phi'} \wedge \gphiImplies {\grad{\phi}} {\grad{\phi_2}}) ~\wedge~ \grad{\phi_2} \mpt \grad{\phi_2'}\\
        &\overset{}{~\quad\implies\quad~} (\exists \grad{\phi'}.~ \dgrad{P}(\grad{\phi_1'}) = \grad{\phi'} \wedge \gphiImplies {\grad{\phi'}} {\grad{\phi_2}}) ~\wedge~ \grad{\phi_2} \mpt \grad{\phi_2'}\\
        &\overset{}{~\quad\implies\quad~} (\exists \grad{\phi'}.~ \dgrad{P}(\grad{\phi_1'}) = \grad{\phi'} \wedge \gphiImplies {\grad{\phi'}} {\grad{\phi_2'}})\\
        &\overset{Def}{~\quad\implies\quad~} \grad{P}(\phi_1', \phi_2') \\
        \end{align*}
    \end{proof}
    
    This observation bridges the gap between $\dgthoare {~} {\cdot} {\cdot} {\cdot}$ and the gradual verifier which is supposed to implement $\gthoare {~} {\cdot} {\cdot} {\cdot}$.
    Optimality of the deterministic lifting does not imply optimality of the obtained gradual lifting.
    
    \begin{example}{Counterexample of Optimality Induced by Deterministic Lifting}
        \label{cex:opt-det2grad}
        Assume that, one can verify
        \begin{displaymath}
        \thoare{}{\phiEq{y}{4}}{\sVarAssign{x}{3}}{\phiAnd{\phiEq{y}{4}}{\phiEq{x}{3}}}
        \end{displaymath}
        and
        \begin{displaymath}
        \thoare{}{\phiEq{y}{5}}{\sVarAssign{x}{3}}{\phiAnd{\phiEq{y}{5}}{\phiEq{x}{3}}}
        \end{displaymath}
        using Hoare logic.
        
        Now, let $\setGFormula$ be extended using the “dedicated wildcard” approach (see section \ref{ssec:dedicated-wildcard-formula}).
        The deterministic lifting of the Hoare logic will verify
        \begin{displaymath}
        \dgthoare{}{\qm}{\sVarAssign{x}{3}}{\qm}
        \end{displaymath}
        The unknown formula as postcondition is necessary, as anything else (e.g. $\phiEq{x}{3}$) would break the strength condition (take the above static judgments, both of their postconditions cannot be implied by any static formula).
        Note that the “wildcard with upper bound” approach (see \ref{ssec:wildcard-with-upper}) would allow specifying $\withqmGen{\phiEq{x}{3}}$ as postcondition.
        
        Using \ref{lem:det2grad} we can deduce
        \begin{displaymath}
        \gthoare{}{\qm}{\sVarAssign{x}{3}}{\phiEq{x}{1}}
        \end{displaymath}
        since $\gphiImplies{\qm}{\phiEq{x}{1}}$ holds.
        An optimal gradual lifting would not be able to deduce this judgment, as it requires the existing of some $\phi \in \gamma(\qm) = \setFormulaA$ such that
        \begin{displaymath}
        \thoare{}{\phi}{\sVarAssign{x}{3}}{\phiEq{x}{1}}
        \end{displaymath}
        holds.
        However, the only working instantiation according to Hoare logic is $\phi = \phiEq{3}{1}$ which is not satisfiable.
        It follows that the obtained lifting is not optimal, even though the deterministic lifting is.
        
        Note that with $\withqmGen{\phiEq{x}{3}}$ as a postcondition, one cannot deduce above gradual judgment (since $\gphiImplies{\withqmGen{\phiEq{x}{3}}}{\phiEq{x}{1}}$) does not hold.
        This example motivates the use of more powerful gradual syntax extensions, as apparently they result in more optimal gradual liftings.
    \end{example}
    
    \item[(b) Determinism of Verifier]~\\
    As the name suggests, deterministic liftings leave no room for choice.
    For the gradual verifier this means that there is no need to infer intermediate formulas, averting the risk of choosing the wrong formulas (as illustrated in section \ref{ssec:the-problem-with}).
    
    \item[(c) Free Transitivity]~\\
    Furthermore, applying Hoare rules transitively induces no more additional runtime cost:
    As described in \ref{ssec:gradual-soundness}, every judgment of the form $\gthoare {~} {\cdot} {\cdot} {\cdot}$ must be accompanied with the injection of a runtime check in order to guarantee preservation.
    Note that applying gradual Hoare logic to a sequence of statements (using GHSec) requires such judgment for every single statement, resulting in assertions between every pair of statements.
    
    Using a deterministic lifting transitively induces no such runtime cost since the no judgment of the form $\gthoare {~} {\cdot} {\cdot} {\cdot}$ is made.
    Only after applying lemma \ref{lem:det2grad} in the very end of verification, an assertion will be injected to ensure preservation for the overall judgment.
    
    \item[(d) Preservation]~\\
    Deterministic liftings are designed in a way that enables defining a stronger notion of preservation that does not rely on runtime assertions.
    \begin{mathpar}
        \inferrule* [Right=GDPreservation]
        {
            \dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
        }
        {
            \gtHoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
        }
    \end{mathpar}
    Note however, that this rule is not automatically satisfied, this also depends on the gradual dynamic semantics of \gvl.
    
    \begin{example}{\tset{GDPreservation} Counterexample}
        \label{ex:cex-gdpres}
        Assume that \svl contains an assertion statement with corresponding Hoare rule.
        \begin{mathpar}
            \inferrule* [Right=HAssert]
            {
                \phiImplies{\phi}{\phi_a}
            }
            {
                \thoare{~}{\phi}{\sAssert{$\phi_a$}}{\phi}
            }
        \end{mathpar}
        Soundness of the Hoare logic implies that assertions are guaranteed to hold at runtime.
        It is therefore reasonable for \svl to implement assertions as no-operations.
        It follows that \gvl implements them the same way.
        
        A valid deterministic lifting of \tset{HAssert} is able to verify
        \begin{displaymath}
        \dgthoare{~}{\qm}{\sAssert{$\phi_a$}}{\withqmGen{\phi_a}}
        \end{displaymath}
        However $\gtHoare{}{\qm}{\sAssert{$\phi_a$}}{\withqmGen{\phi_a}}$ does not hold (if $\phi_a$ is not $\phiTrue$):
        Choose $\grad{\pi}, \grad{\pi'} \in \setGProgramState$ such that $\gsstepConsume{\sAssert{$\phi_a$}}{\grad{\pi}}{\grad{\pi'}}$ holds.
        Furthermore we demand $\neg \evalgphiGen{\grad{\pi}}{\withqmGen{\phi_a}}$ (such a program state exists since $\phi_a$ is not $\phiTrue$).
        Since the assertion is a no-operation, it follows that $\neg \evalgphiGen{\grad{\pi'}}{\withqmGen{\phi_a}}$.
        According to definition \ref{def:valid-hoare-triple}, we can deduce from $\gtHoare{}{\qm}{\sAssert{$\phi_a$}}{\withqmGen{\phi_a}}$ that $\evalgphiGen{\grad{\pi'}}{\withqmGen{\phi_a}}$.
        This would be a contradiction.
        
        
        On the other hand, a small-step semantics that is stuck or throws an exception if the assertion is violated would restore preservation.
        In general, small-step semantics that are rely on guarantees given by static semantics may turn out too weak after gradualization of the static semantics.
    \end{example}
\end{description}