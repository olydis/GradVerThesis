% generic language introduction

Requirements:

\begin{description}
\item[Syntax] ~\\
    We assume the existence of at least the following two syntactic categories:
    \begin{align*}
    	s    & \in \setStmt    \\
    	\phi & \in \setFormula
    \end{align*}
    We assume that there is a sequence operator \ttt{;} such that: $\forall s_1, s_2 \in \setStmt.~~ s_1\ttt{;}s_2 \in \setStmt$
    % or munch that into syntax figure above?
    % TODO: we make no other assumptions
    % To illustrate certain points, we will make ad-hoc assumptions about the syntax and semantics.
    
    % FORMALIZE \setProgramState, \setProgramState_{...}

\item[Program State]
    $\setProgramState$
    $\setProgramState_s$

\item[Formula Semantics]~\\
    Formulas are used to describe program states.
    For example, a method contract stating $\ttt{arg > 4}$ as precondition is supposed to make sure that the method is only entered, if $\ttt{arg}$ evaluates to a value larger than $4$ in the current program state.
    
    We assume that we are given a computable predicate
    \begin{displaymath}
    \evalphiGen{\cdot}{\cdot} ~\subseteq~ \setProgramState \times \setFormula
    \end{displaymath}
    that decides, whether a formula is satisfied given a concrete program state.
    
    % EXAMPLES examples examples
    
    We can derive a notion of satisfiability, implication and equivalence from this evaluation predicate.
    
    \begin{definition}[Formula Satisfiability]~\\
        A formula $\phi$ is \textbf{satisfiable} iff
        \begin{displaymath}
        \exists \pi \in \setProgramState.~ \evalphiGen{\pi}{\phi}
        \end{displaymath}
        Let $\setFormulaA \subseteq \setFormula$ be the set of satisfiable formulas.
    \end{definition}
    
    \begin{definition}[Formula Implication]~\\
        A formula $\phi_1$ \textbf{implies} formula $\phi_2$ (written $\phiImplies{\phi_1}{\phi_2}$) iff
        \begin{displaymath}
        \forall \pi \in \setProgramState.~ \evalphiGen{\pi}{\phi_1} \implies \evalphiGen{\pi}{\phi_2}
        \end{displaymath}
    \end{definition}
    
    \begin{definition}[Formula Equivalence]~\\
        Two formulas $\phi_1$ and $\phi_2$ are \textbf{equivalent} (written $\phi_1 \equiv \phi_2$) iff
        \begin{displaymath}
        \phiImplies{\phi_1}{\phi_2} ~~\wedge~~ \phiImplies{\phi_2}{\phi_1}
        \end{displaymath}
    \end{definition} 
    
    % TODO examples
    
    \begin{lemma}[Partial Order of Formulas]~\\
        The implication predicate is a partial order on $\setFormula$.
    \end{lemma}
    % PROOF
    
    We assume that there is a largest element $\phiTrue \in \setFormula$.
    Note that the presence of an unsatisfiable formula (as invariant, pre-/postcondition, assertion, ...) in a sound verification system implies that the corresponding source code location is unreachable:
    Preservation guarantees that any reachable program state satisfies potentially annotated formulas, trivially implying that the formula is satisfiable.
    
    This property is true regardless of whether \gsvl forbids usage of unsatisfiable formulas entirely or whether it only fails when trying to use the corresponding code (which would involve proving that a satisfiable formula implies an unsatisfiable one).
    Therefore we will often restrict our reasoning on the satisfiable formulas $\setFormulaA$, without explicitly stating that the presence of an unsatisfiable formula would result in failure.
    
\item[Static Semantics]~\\
    We assume that there is a Hoare logic (HL)
    \begin{displaymath}
    \thoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormulaA \times \setStmt \times \setFormulaA
    \end{displaymath}
    describing which programs (together with pre- and postconditions about the program state) are accepted.
    While the Hoare logic might be defined for arbitrary formulas in practice, we only ever reason about it in presence of satisfiable formulas, hence the “restricted domain”???.
    
    In practice, this predicate might also have further parameters. 
    For instance, a statically typed language might require a type context to safely deduce $$\thoare{\ex{x} : \Tint}{\phiTrue}{\sVarAssign{x}{3}}{\phiEq{x}{3}}$$
    As we will see later, further parameters are generally irrelevant for and immune to gradualization, so it is reasonable to omit them for now.
    % TODO: program als parameter...
    
    %% SEQ
    We assume that 
    \begin{mathpar}
        \inferrule* [Right=HoareSequence]
        {
            \thoare {~} {\phi_p} {{s_1}} {\phi_q} \\
            \thoare {~} {\phi_q} {\overline{s_2}} {\phi_r}
        }
        {
            \thoare {~} {\phi_p} {{s_1}\ttt{;~} {\overline{s_2}}} {\phi_r}
        }
    \end{mathpar}
    is derivable from given Hoare rules. % OR with both parts as lists?
    
    %% "wsp" - wlp, but with static instead of dynamic semantics!!!
    \begin{definition}[Weakest Static Precondition]~\\
        Let $\wsp : \setStmt \rightarrow \PP(\setProgramState)$ be defined as
        \begin{displaymath}
        \wsp(s) = \{~ \pi \in \setProgramState ~|~ \exists \phi_1, \phi_2 \in \setFormula.~ \thoare{~}{\phi_1}{s}{\phi_2} ~~\wedge~~ \evalphiGen{\pi}{\phi_1} ~\}
        \end{displaymath}
    \end{definition}
    Intuitively, the $\wsp(s)$ is a predicate on program states, indicating whether we could deduce anything about the state after executing $s$, using only our Hoare rules.
    We require that $\wsp$ is computable at least for atomic statements and that the resulting predicate is computable as well.
    
    Example:
    \begin{itemize}
        \item 
        Given that
        \begin{mathpar}
            \inferrule* [Right=HoareAssign]
            {
                ~
            }
            {
                \thoare {~} {\phi[e/x]} {\sVarAssign {${x}$} {${e}$}} {\phi}
            }
        \end{mathpar}
        is the only Hoare rule for assignment, it follows that
        \begin{displaymath}
        \wsp(\sVarAssign {${x}$} {${e}$}) = \setProgramState
        \end{displaymath}
        
        \item 
        Given that
        \begin{mathpar}
            \inferrule* [Right=HoareStaticAssert]
            {
                \phiImplies{\phi}{\phi_a}
            }
            {
                \thoare {~} {\phi} {\sAssert {$\phi_a$}} {\phi}
            }
        \end{mathpar}
        is the only Hoare rule for assertions, it follows that
        \begin{displaymath}
        \wsp(\sAssert {$\phi_a$}) = \{~ \pi \in \setProgramState ~|~ \evalphiGen{\pi}{\phi_a} ~\}
        \end{displaymath}
    \end{itemize}
    % TODO: x := 3; assert (x = 2);   EXAMPLE?
    
    % Note that this definition is similar to the weakest liberal precondition $\predicate{wlp}$
    
    %% information monotonic - required?
    We further assume that this predicate is monotonic in the precondition w.r.t. implication:
    \begin{align*}
    \forall s \in \setStmt.~& \\
    \forall \phi_1, \phi_2 \in \setFormula.~&\\
    \forall \phi_1' \in \setFormula.~&
    (\phiImplies {\phi_1} {\phi_2}) ~~\wedge~ \thoare {~} {\phi_1} {s} {\phi_1'}\\
    \implies
    \exists \phi_2' \in \setFormula.~&
    (\phiImplies {\phi_1'} {\phi_2'}) ~~\wedge~ \thoare {~} {\phi_2} {s} {\phi_2'}
    \end{align*}
    
    Intuitively, this means that more knowledge about the initial program state can not result in a loss of information about the final state.
    
    
%\item[Notion of Well-Formedness]
    % formally that can be covered by static semantics!!!
    
    
\item[Dynamic Semantics]~\\
    We assume that there is a small-step semantics $~\sssem \subseteq \setProgramState \rightharpoonup \setProgramState$ describing precisely how program state can be updated.
    %We assume that there is a small-step semantics $~\sssem \subseteq \setProgramState \rightarrow \PP(\setProgramState)$ describing precisely how program state can be updated.
    %Note that this signature allows for non-deterministic (e.g. concurrent) semantics.
    %Execution is considered stuck in state $\pi$ iff $\sssem(\pi) = \emptyset$
    
    We further assume that there is a designated non-empty set $~\setProgramStateFin \subseteq \setProgramState~$ of states indicating regular termination of the program.
    W.l.o.g. we assume $\dom(\sssem) \cap \setProgramStateFin = \emptyset$, e.g. final states are stuck.
    Optionally, there may be a subset $~\setProgramStateEx \subseteq \setProgramStateFin~$ of states indicating exceptional termination of the program.
    To simplify reasoning about exceptional states, we assume $$\forall \pi_X \in \setProgramStateEx, \phi \in \setFormula.~ \evalphiGen{\pi_X}{\phi}$$ and something with special instruction set?
    
    %To indicate that states $\overline{\pi_2}$ can be obtained from state $\pi_1$ in $n$ steps, we write $\sssem^n(\pi_1)$.
    %If the specific number of steps is irrelevant, we write $\sssem^*(\pi_1, \pi_2)$.
    
    % Execution is considered to be stuck iff there are no more 
    
    % define \evalphiXGen{arg1}{arg2}
    
\item[Soundness]~\\
    We expect that given static semantics are sound w.r.t. given dynamic semantics.
    \begin{mathpar}
        \inferrule* [Right=Soundness]
        {
            \thoare{~}{\phi_1}{s}{\phi_2} \\ 
            \pi_s \in \setProgramState_s\\
            \evalphiGen{\pi_s}{\phi_1}
        }
        {
            \evalphiGen{\sssem^s(\pi_s)}{\phi_2}
        }
    \end{mathpar}
    Note how progress is covered by expecting that $\sssem^s(\pi_s)$ is defined.
\end{description}
