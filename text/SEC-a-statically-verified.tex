%% generic language introduction
While aiming to give a general procedure for deriving gradually verified languages, we have to make certain assumptions about \svl in order to concisely describe our approach and reason about its correctness.
We believe that most statically verified programming languages satisfy the following assumptions and thus qualify as starting point for our procedure.

Assumptions about \svl:
\begin{description}
\item[Syntax]~\\
    We assume the existence of the following two syntactic categories:
    \begin{align*}
    	s    & \in \setStmt    \\
    	\phi & \in \setFormula
    \end{align*}
    
    We assume that there is a sequence operator \ttt{;} such that: $$\forall s_1, s_2 \in \setStmt.~~ s_1\ttt{;}s_2 \in \setStmt$$
    % or munch that into syntax figure above?
    
    \begin{comment}
    Let $\setStmt_s$ be the set of all statements having $s$ as prefix.
    \end{comment}
    
    % examples, formal?
    
    % TODO: we make no other assumptions
    % To illustrate certain points, we will make ad-hoc assumptions about the syntax and semantics.
    
\item[Program State]~\\
    Dynamic semantics (see below) are formalized as discrete transitions between program states.
    Therefore a program state contains all information necessary to evaluate expressions and determine the next program state.
    We assume that $\setProgramState$ is the set of all possible program states in \svl.
    
    Examples:
    \begin{description}
        \item[Primitive language with integer variables]
        \begin{displaymath}
        \setProgramState ~=~ \underbrace{(\setVar \rightharpoonup \mathbb{Z})}_{\textit{variable memory}} ~\times~ \setStmt 
        \end{displaymath}
        
        \item[Language with stack]
        \begin{displaymath}
        \setProgramState ~=~ \bigcup_{i \in \mathbb{N}_+}{\underbrace{\Big((\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt \Big)}_{\textit{stack frame}}}^i                                                      
        \end{displaymath}
    \end{description}
    
    Note how these examples use statements to represent continuations (the “remaining work”), necessary for the operational semantics to deduce a state transition.
    In general, a different representation may be used to...
    
    \begin{comment}
    In order to determine the next program state (or detect termination), a state must have a notion of “upcoming work”, usually represented by a statement internally.
    TODO: reasonable to call that “continuation”?
    
    Let $\setProgramState_s$ (with $s \in \setStmt$) be the set of program states having $s$ as upcoming work.
    This notion will be necessary to define soundness of \svl's static semantics.
    
    Examples:
    \begin{description}
        \item[Primitive]
        \begin{flalign*}
        	 & \setProgramState ~=~ \underbrace{(\setVar \rightharpoonup \mathbb{Z})}_{\textit{variable memory}} ~\times~ \setStmt & ~ \\
        	 & \setProgramState_s ~=~ (\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt_s                                     &
        \end{flalign*}
        
        \item[Stack]
        \begin{flalign*}
        	 & \setProgramState ~=~ \bigcup_{i \in \mathbb{N}_+}{\underbrace{\Big((\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt \Big)}_{\textit{stack frame}}}^i                                                                                \\
        	 & \setProgramState_s ~=~ \Big((\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt_s\Big) ~\times~ \underbrace{\bigcup_{i \in \mathbb{N}_0}{\Big((\setVar \rightharpoonup \mathbb{Z}) ~\times~ \setStmt \Big)^i}}_{\textit{lower frames}}
        \end{flalign*}
    \end{description}
     
    TODO: notion of initial state?
    \end{comment}
    
    
\item[Dynamic Semantics]~\\
    We assume that \svl has a structural operational semantics or small-step semantics.
    This semantics is formalized as $~\sssem : \setProgramState \rightharpoonup \setProgramState$, describing precisely how program state can be updated. % TODO: reconsider non-deterministic
    %We assume that there is a small-step semantics $~\sssem \subseteq \setProgramState \rightarrow \PP(\setProgramState)$ describing precisely how program state can be updated.
    %Note that this signature allows for non-deterministic (e.g. concurrent) semantics.
    %Execution is considered stuck in state $\pi$ iff $\sssem(\pi) = \emptyset$
    Taking $n$ steps at once can be abbreviated as $\sssem^n$ (undefinedness is propagated).
    
    \begin{flalign*}
        &\sssem^s \subseteq \setProgramState_s \times \setProgramState & \\
        &\sssem^s(\pi_s, \pi) ~\defiff~ \exists n \in \setNat.~ \sssem^n(\pi_s) = \pi ~\wedge~ \pi \text{ is the first state after $s$ is fully consumed}
    \end{flalign*}
    
    We further assume that there is a designated non-empty set $~\setProgramStateFin \subseteq \setProgramState~$ of states indicating regular or exceptional termination of the program.
    \begin{comment}
    W.l.o.g. we assume $\dom(\sssem) \cap \setProgramStateFin = \emptyset$, e.g. final states are stuck.
    Optionally, there may be a subset $~\setProgramStateEx \subseteq \setProgramStateFin~$ of states indicating exceptional termination of the program.
    To simplify reasoning about exceptional states, we assume $$\forall \pi_X \in \setProgramStateEx, \phi \in \setFormula.~ \evalphiGen{\pi_X}{\phi}$$ and something with special statement set?
    
    %To indicate that states $\overline{\pi_2}$ can be obtained from state $\pi_1$ in $n$ steps, we write $\sssem^n(\pi_1)$.
    %If the specific number of steps is irrelevant, we write $\sssem^*(\pi_1, \pi_2)$.
    
    % Execution is considered to be stuck iff there are no more 
    \end{comment}
    
\item[Formula Semantics]~\\
    Formulas are used for annotations like method contracts or invariants.
    Formally they constrain program states. % more verbose? can be viewed as types?
    For example, a method contract stating $\ttt{arg > 4}$ as precondition is supposed to make sure that the method is only entered, if $\ttt{arg}$ evaluates to a value larger than $4$ in the program state at the call site.
    
    We assume that we are given a computable predicate
    \begin{displaymath}
    \evalphiGen{\cdot}{\cdot} ~\subseteq~ \setProgramState \times \setFormula
    \end{displaymath}
    that decides, whether a formula is satisfied given a concrete program state.
    
    % EXAMPLES examples examples
    
    We can derive a notion of satisfiability, implication and equivalence from this evaluation predicate.
    
    \begin{definition}[Formula Satisfiability]~\\
        A formula $\phi$ is \textbf{satisfiable} iff
        \begin{displaymath}
        \exists \pi \in \setProgramState.~ \evalphiGen{\pi}{\phi}
        \end{displaymath}
        Let $\setFormulaA \subseteq \setFormula$ be the set of satisfiable formulas.
    \end{definition}
    
    \begin{definition}[Formula Implication]~\\
        A formula $\phi_1$ \textbf{implies} formula $\phi_2$ (written $\phiImplies{\phi_1}{\phi_2}$) iff
        \begin{displaymath}
        \forall \pi \in \setProgramState.~ \evalphiGen{\pi}{\phi_1} \implies \evalphiGen{\pi}{\phi_2}
        \end{displaymath}
    \end{definition}
    
    \begin{definition}[Formula Equivalence]~\\
        Two formulas $\phi_1$ and $\phi_2$ are \textbf{equivalent} (written $\phi_1 \equiv \phi_2$) iff
        \begin{displaymath}
        \phiImplies{\phi_1}{\phi_2} ~~\wedge~~ \phiImplies{\phi_2}{\phi_1}
        \end{displaymath}
    \end{definition} 
    
    % TODO examples
    
    \begin{lemma}[Partial Order of Formulas]~\\
        The implication predicate is a partial order on $\setFormula$.
    \end{lemma}
    % PROOF
    
    We assume that there is a largest element $\phiTrue \in \setFormula$.
    Note that the presence of an unsatisfiable formula (as invariant, pre-/postcondition, assertion, ...) in a sound verification system implies that the corresponding source code location is unreachable:
    Preservation guarantees that any reachable program state satisfies potentially annotated formulas, trivially ensuring that the formula is satisfiable.
    
    This property is true regardless of whether \svl forbids usage of unsatisfiable formulas entirely or whether it only fails when trying to use the corresponding code (which would involve proving that a satisfiable formula implies an unsatisfiable one).
    Therefore we will often restrict our reasoning on the satisfiable formulas $\setFormulaA$, without explicitly stating that the presence of an unsatisfiable formula would result in failure.
    
    With this semantics we can formalize the notion of valid Hoare triples:
    \begin{flalign*}
    & \tHoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormula \times \setStmt \times \setFormula                                                                                            \\
    & \tHoare {~} {\phi_{pre}} {s} {\phi_{post}} ~\defiff~ 
    \forall \langle \pi_{pre}, \pi_{post} \rangle \in \sssem^s.~ \evalphiGen{\pi_{pre}}{\phi_{pre}} \implies \evalphiGen{\pi_{post}}{\phi_{post}}
    \end{flalign*}
    
\item[Static Semantics]~\\
    We assume that there is a Hoare logic (HL)
    \begin{displaymath}
    \thoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormulaA \times \setStmt \times \setFormulaA
    \end{displaymath}
    describing which programs (together with pre- and postconditions about the program state) are accepted.
    While the Hoare logic might be defined for arbitrary formulas in practice, we only ever reason about it in presence of satisfiable formulas, hence the “restricted domain”???.
    
    In practice, this predicate might also have further parameters. 
    For instance, a statically typed language might require a type context to safely deduce $$\thoare{\ex{x} : \Tint}{\phiTrue}{\sVarAssign{x}{3}}{\phiEq{x}{3}}$$
    As we will see later, further parameters are generally irrelevant for and immune to gradualization, so it is reasonable to omit them for now.
    % TODO: program als parameter...
    
    %% SEQ
    We assume that 
    \begin{mathpar}
        \inferrule* [Right=HoareSequence]
        {
            \thoare {~} {\phi_p} {{s_1}} {\phi_q} \\
            \thoare {~} {\phi_q} {{s_2}} {\phi_r}
        }
        {
            \thoare {~} {\phi_p} {\sSeq{$s_1$}{$s_2$}} {\phi_r}
        }
    \end{mathpar}
    is derivable from given Hoare rules. % OR with both parts as lists?
    
    %% information monotonic - required?
    We further assume that this predicate is monotonic in the precondition w.r.t. implication:
    \begin{align*}
    \forall s \in \setStmt.~& \\
    \forall \phi_1, \phi_2 \in \setFormula.~&\\
    \forall \phi_1' \in \setFormula.~&
    (\phiImplies {\phi_1} {\phi_2}) ~~\wedge~ \thoare {~} {\phi_1} {s} {\phi_1'}\\
    \implies
    \exists \phi_2' \in \setFormula.~&
    (\phiImplies {\phi_1'} {\phi_2'}) ~~\wedge~ \thoare {~} {\phi_2} {s} {\phi_2'}
    \end{align*}
    
    Intuitively, this means that more knowledge about the initial program state can not result in a loss of information about the final state.
    
    %% "wsp" - wlp, but with static instead of dynamic semantics!!!
    \begin{definition}[Weakest Static Precondition]~\\
        Let $\wsp : \setStmt \rightarrow \PP(\setProgramState)$ be defined as
        \begin{displaymath}
        \wsp(s) = \{~ \pi \in \setProgramState_s ~|~ \exists \phi_1, \phi_2 \in \setFormula.~ \thoare{~}{\phi_1}{s}{\phi_2} ~~\wedge~~ \evalphiGen{\pi}{\phi_1} ~\}
        \end{displaymath}
    \end{definition}
    Intuitively, the $\wsp(s)$ is a predicate on program states, indicating whether we could deduce anything about the state after executing $s$, using only our Hoare rules.
    
    Example:
    \begin{itemize}
        \item 
        Given that
        \begin{mathpar}
            \inferrule* [Right=HoareAssign]
            {
                ~
            }
            {
                \thoare {~} {\phi[e/x]} {\sVarAssign {${x}$} {${e}$}} {\phi}
            }
        \end{mathpar}
        is the only Hoare rule for assignment, it follows that
        \begin{displaymath}
        \wsp(\sVarAssign {${x}$} {${e}$}) = \setProgramState
        \end{displaymath}
        
        \item 
        Given that
        \begin{mathpar}
            \inferrule* [Right=HoareStaticAssert]
            {
                \phiImplies{\phi}{\phi_a}
            }
            {
                \thoare {~} {\phi} {\sAssert {$\phi_a$}} {\phi}
            }
        \end{mathpar}
        is the only Hoare rule for assertions, it follows that
        \begin{displaymath}
        \wsp(\sAssert {$\phi_a$}) = \{~ \pi \in \setProgramState ~|~ \evalphiGen{\pi}{\phi_a} ~\}
        \end{displaymath}
    \end{itemize}
    % TODO: x := 3; assert (x = 2);   EXAMPLE?
    
    % Note that this definition is similar to the weakest liberal precondition $\predicate{wlp}$
    
    % we use this static semantics to check e.g. method contracts
    
%\item[Notion of Well-Formedness]
    % formally that can be covered by static semantics!!!
    
\item[Soundness]~\\
    We expect that given static semantics are sound w.r.t. given dynamic semantics.
    \begin{mathpar}
        \inferrule* [Right=Progress]
        {
            ???
        }
        {
            ???
        }
    \end{mathpar}
    \begin{comment}
        \inferrule* [Right=Progress]
        {
            \pi \in \wsp(s_1) \\ 
        }
        {
            \exists n \in \setNat,\, s_2 \in \setStmt.~ \sssem^n(\pi) \in \setProgramState_{s_2}
        }
    \end{comment}
    \begin{mathpar}
        \inferrule* [Right=Preservation]
        {
            \thoare{~}{\phi_1}{s}{\phi_2}
        }
        {
            \tHoare{~}{\phi_1}{s}{\phi_2}
        }
    \end{mathpar}
    % progress blabla
\end{description}
