% generic language introduction

Requirements:

\begin{description}
\item[Syntax] ~\\
    We assume the existence of at least the following two syntactic categories:
    \begin{align*}
    	s    & \in \setStmt    \\
    	\phi & \in \setFormula
    \end{align*}
    % TODO: we make no other assumptions
    % To illustrate certain points, we will make ad-hoc assumptions about the syntax and semantics.
    
\item[Formula Semantics]~\\
    Formulas are used to describe program states.
    For example, a method contract stating $\ttt{arg > 4}$ as precondition is supposed to make sure that the method is only entered, if $\ttt{arg}$ evaluates to a value larger than $4$ in the current program state.
    
    We assume that we are given a predicate
    \begin{displaymath}
    \evalphiGen{\cdot}{\cdot} ~\subseteq~ \setProgramState \times \setFormula
    \end{displaymath}
    that decides, whether a formula is satisfied given a concrete program state.
    
    % EXAMPLES examples examples
    
    This also induces notion of implication!!! % TODO
    % also talk about partially ordered set induced by that... name largest element "true" (expect that to exist!), etc.
    
\item[Static Semantics]~\\
    We assume that there is an axiomatic semantics
    \begin{displaymath}
    \thoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormula \times \setStmt \times \setFormula
    \end{displaymath}
    describing which programs (together with pre- and postconditions about the program state) are accepted.
    In practice, this predicate might have further parameters. 
    For instance, a statically typed language might require a type context to safely deduce $$\thoare{\ex{x} : \Tint}{\phiTrue}{\sVarAssign{x}{3}}{\phiEq{x}{3}}$$
    As we will see later, further parameters are generally irrelevant for and immune to gradualization, so it is reasonable to omit them for now.
    
    We further assume that there is always some way to decompose judgments about a sequence of statements into judgments about parts of that sequence, all the way down to single statements. 
    Usually this is achieved with a sequence rule. Examples:
    \begin{mathpar}
        \inferrule* [Right=VerSeqSyntaxDriven]
        {
            \thoare {~} {\phi_p} {{s_1}} {\phi_q} \\
            \thoare {~} {\phi_q} {\overline{s_2}} {\phi_r}
        }
        {
            \thoare {~} {\phi_p} {{s_1}\ttt{;~} {\overline{s_2}}} {\phi_r}
        }
    \end{mathpar}
    \begin{mathpar}
        \inferrule* [Right=VerSeqFlexible]
        {
            \thoare {~} {\phi_p} {\overline{s_1}} {\phi_{q1}} \\
            \phi_{q1} \implies \phi_{q2}\\
            \thoare {~} {\phi_{q2}} {\overline{s_2}} {\phi_r}
        }
        {
            \thoare {\Gamma} {\phi_p} {\overline{s_1}\ttt{;~} {\overline{s_2}}} {\phi_r}
        }
    \end{mathpar}
    
    %% verify-predicate
    Some axiomatic semantics are not flexible enough to directly use them for checking method contracts.
    For example a rule like
    \begin{mathpar}
        \inferrule* [Right=VerReturn]
        {
        }
        {
            \thoare {~} {\phi} {\sReturn{x}} {\phi /\ \phiEq{\eresult}{x}}
        }
    \end{mathpar}
    cannot prove
    \begin{lstlisting}
    int test(int noise)
        requires noise != 42;
        ensures  result > 0;
    {
        return 3;
    }
    \end{lstlisting}
    as there is no matching instantiation of the rule.
    
    By definition of implication, a sound verification system stays sound if we embed the axiomatic semantics between implications and instead use the resulting predicate for verification. % PROOF?
    \begin{definition}[Generic Verification Predicate]
        \begin{align*}
        \verify(\phi_{pre}, \overline{s}, \phi_{post}) \overset{\predicate{def}}{\iff} \exists \phi_{pre}', \phi_{post}'.
        &~~ \phi_{pre} \implies \phi_{pre}' \\
        \wedge& \thoare {~} {\phi_{pre}'} {\overline{s}} {\phi_{post}'} \\
        \wedge&~~ \phi_{post}' \implies \phi_{post}
        \end{align*}
    \end{definition}
    Note that the predicate is equivalent to the axiomatic semantics, in case it already takes implications into account.
    Yet, uncoupling axiomatic semantics and the actual verification predicate will prove extremely useful for gradualization.
    
    % We assume that \gsvl has this kind of flexibility.
    
    To abstract from specific implementations and not force flexibility 

\item[Notion of Well-Formedness]
    
    
    
\item[Dynamic Semantics]~\\
    We assume that there is a dynamic semantics (e.g. small-step) describing precisely whether and how program state is updated.
    This is required mainly for reasoning about soundness of the static semantics.
    % NOTE: allow for non-deterministic semantics!
    
\item[Soundness]~\\
    We expect that given static semantics are sound w.r.t. given dynamic semantics.
    This means that programs satisfying ... 
\end{description}