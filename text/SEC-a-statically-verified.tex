% generic language introduction

Requirements:

\begin{description}
\item[Syntax] ~\\
    We assume the existence of at least the following two syntactic categories:
    \begin{align*}
    	s    & \in \setStmt    \\
    	\phi & \in \setFormula
    \end{align*}
    % TODO: we make no other assumptions
    % To illustrate certain points, we will make ad-hoc assumptions about the syntax and semantics.
    
    We write $\setStmts$ for the set of lists of instructions. % TODO: formally?
    ...and use $\overline{\cdot}$ to decorate variables representing lists of things.
    
\item[Formula Semantics]~\\
    Formulas are used to describe program states.
    For example, a method contract stating $\ttt{arg > 4}$ as precondition is supposed to make sure that the method is only entered, if $\ttt{arg}$ evaluates to a value larger than $4$ in the current program state.
    
    We assume that we are given a predicate
    \begin{displaymath}
    \evalphiGen{\cdot}{\cdot} ~\subseteq~ \setProgramState \times \setFormula
    \end{displaymath}
    that decides, whether a formula is satisfied given a concrete program state.
    
    % EXAMPLES examples examples
    
    We can derive a notion of satisfiability, implication and equivalence from this evaluation predicate.
    
    \begin{definition}[Formula Satisfiability]~\\
        A formula $\phi$ is \textbf{satisfiable} iff
        \begin{displaymath}
        \exists \pi \in \setProgramState.~ \evalphiGen{\pi}{\phi}
        \end{displaymath}
        Let $\setFormulaA \subseteq \setFormula$ be the set of satisfiable formulas.
    \end{definition}
    
    \begin{definition}[Formula Implication]~\\
        A formula $\phi_1$ \textbf{implies} formula $\phi_2$ (written $\phiImplies{\phi_1}{\phi_2}$) iff
        \begin{displaymath}
        \forall \pi \in \setProgramState.~ \evalphiGen{\pi}{\phi_1} \implies \evalphiGen{\pi}{\phi_2}
        \end{displaymath}
    \end{definition}
    
    \begin{definition}[Formula Equivalence]~\\
        Two formulas $\phi_1$ and $\phi_2$ are \textbf{equivalent} (written $\phi_1 \equiv \phi_2$) iff
        \begin{displaymath}
        \phiImplies{\phi_1}{\phi_2} ~~\wedge~~ \phiImplies{\phi_2}{\phi_1}
        \end{displaymath}
    \end{definition} 
    
    % TODO examples
    
    \begin{lemma}[Partial Order of Formulas]~\\
        The implication predicate is a partial order on $\setFormula$.
    \end{lemma}
    % PROOF
    
    We assume that there is a largest element $\phiTrue \in \setFormula$.
    Note that the presence of an unsatisfiable formula (as invariant, pre-/postcondition, assertion, ...) in a sound verification system implies that the corresponding source code location is unreachable:
    Preservation guarantees that any reachable program state satisfies potentially annotated formulas, trivially implying that the formula is satisfiable.
    
    This property is true regardless of whether \gsvl forbids usage of unsatisfiable formulas entirely or whether it only fails when trying to use the corresponding code (which would involve proving that a satisfiable formula implies an unsatisfiable one).
    Therefore we will often restrict our reasoning on the satisfiable formulas $\setFormulaA$, without explicitly stating that the presence of an unsatisfiable formula would result in failure.
    
\item[Static Semantics]~\\
    We assume that there is a Hoare logic (HL)
    \begin{displaymath}
    \thoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormulaA \times \setStmts \times \setFormulaA
    \end{displaymath}
    describing which programs (together with pre- and postconditions about the program state) are accepted.
    While the Hoare logic might be defined for arbitrary formulas in practice, we only ever reason about it in presence of satisfiable formulas, hence the “restricted domain”???.
    
    In practice, this predicate might also have further parameters. 
    For instance, a statically typed language might require a type context to safely deduce $$\thoare{\ex{x} : \Tint}{\phiTrue}{\sVarAssign{x}{3}}{\phiEq{x}{3}}$$
    As we will see later, further parameters are generally irrelevant for and immune to gradualization, so it is reasonable to omit them for now.
    
    %% NOT REQUIRED AFTER ALL
    %We further assume that this predicate is monotonic in the precondition w.r.t. implication:
    %\begin{align*}
    %\forall \overline{s} \in \setStmts.~& \\
    %\forall \phi_1, \phi_2 \in \setFormula.~&\\
    %\forall \phi_1' \in \setFormula.~&
    %(\phiImplies {\phi_1} {\phi_2}) ~~\wedge~ \thoare {~} {\phi_1} {\overline{s}} {\phi_1'}\\
    %\implies
    %\exists \phi_2' \in \setFormula.~&
    %(\phiImplies {\phi_1'} {\phi_2'}) ~~\wedge~ \thoare {~} {\phi_2} {\overline{s}} {\phi_2'}
    %\end{align*}
    
\item[Notion of Well-Formedness]
    
    
    
\item[Dynamic Semantics]~\\
    We assume that there is a dynamic semantics (e.g. small-step) describing precisely whether and how program state is updated.
    This is required mainly for reasoning about soundness of the static semantics.
    % NOTE: allow for non-deterministic semantics!
    
\item[Soundness]~\\
    We expect that given static semantics are sound w.r.t. given dynamic semantics.
    This means that programs satisfying ... 
\end{description}