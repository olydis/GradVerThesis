%% Naive approach
With the rules for lifting set up we can apply them to the static verification predicate:
Lifting 
$$\thoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormula \times \setStmt \times \setFormula$$
w.r.t. both pre- and postcondition results in a predicate
$$\gthoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setGFormula \times \setStmt \times \setGFormula$$

% EXAMPLE with proof

% now: preservation broken - only fix puts verifier in dilemma!

\textbf{Restoring Soundness}\\
Recall what soundness means for a static verification system:
Assume that $\thoare {~} {\phi_{pre}} {\overline{s}} {\phi_{post}}$ holds in the static verification system.
Given a program state that satisfies $\phi_{pre}$, soundness guarantees us both that execution won't get blocked when executing $\overline{s}$ (progress) and that the program state satisfies $\phi_{post}$ afterwards (preservation).

It turns out that additional measures are necessary for both progress and preservation.
We will first focus on preservation, assuming that statements do not cause the runtime to be in a blocked state.

Consider a sound static verification system that allows verifying:
\begin{mathpar}
\inferrule* [Right=VerAssign]
{ ... }
{
    \thoare {~} {\phiEq{x}{2}} {\sVarAssign{y}{3}} {\phiEq{x}{2} \wedge \phiEq{y}{3}}
}
\end{mathpar}

With the rules of lifting we can deduce
\begin{align*}
&&\thoare {~} {\phiEq{x}{2}} {\sVarAssign{y}{3}} {\phiEq{x}{2} \wedge \phiEq{y}{3}}&\\
\overset{Introduction?}{\implies}&&
\gthoare {~} {\phiEq{x}{2}} {\sVarAssign{y}{3}} {\phiEq{x}{2} \wedge \phiEq{y}{3}}&\\
\overset{Monotonicity?}{\implies}&&
\gthoare {~} {\qm} {\sVarAssign{y}{3}} {\phiEq{x}{2} \wedge \phiEq{y}{3}}&
\end{align*}

Preservation is apparently not ensured in a runtime that lets the assignment succeed: 
While the precondition does not put any restriction on the value of \ttt{x}, the postcondition claims that \ttt{x} does have a certain value.
From a logical perspective the runtime can fix this problem in two ways:
\begin{description}
    \item[“Fix” the program state]~\\
    The only way to actually make the postcondition true would involve altering the program state to satisfy the formula.
    This is not an option as it actively interferes with the program state.
    Verification conditions should not bend reality in order to hold, they have a rather passive role of checking reality.
    
    \item[]~\\
    Preservation is only expected to hold in case execution actually reaches the postcondition.
    The runtime could artificially terminate in case the postcondition is not satisfied.
    This approach is unsatisfying as it trivially achieves soundness, effectively making the notion worthless:
    Any “verification system” can be made sound by just terminating exceptionally whenever progress or preservation are about to be violated.
\end{description}

The first way to fix this problem would be 

Note that the intermediate formula $\phiEq{x}{2}$ does not show up in the final judgment, i.e. it was up to the verifier to “come up” with a formula that makes the overall proof work -- a valid alternative would have been $\phiNeq{x}{0}$.
Still, preservation also applies to “hidden” judgments (after all we could look at them isolated, so soundness must apply), so we are guaranteed that the program state satisfies $\phiEq{x}{2}$ (and also $\phiNeq{x}{0}$) after the first statement is executed.

The same reasoning does not apply to the lifted verification predicate: 


Yet, soundness guarantees that


Apparently the precondition does not restrict the program state before executing the assertion.
Let's assume that we 

In the static system, we are guaranteed that the runtime satisfies a postcondition, given that the precondition should execution
There is something fundamentally wrong with this 



% non-deterministic static hoare rules make “quality of lifting” reasoning hard! if even {a}...{true} is valid statically, how to express/measure “badness” of emitting {a}...{?}
% Hoare rules (in a sound language) GUARANTEE that intermediate formulas hold at runtime 
% non-deterministic gradual hoare rules do NOT guarantee that!

% take burdon of chosing “good” intermediate formulas off verifier:
\begin{verbatim}
{ ? }
x := 2;
{ ? } // too weak, not optimal
assert (x = 3);
\end{verbatim}
\begin{verbatim}
{ ? }
assert (x != 0);
{ (x = 42) } // too strong, “somewhat unsound!!!” (no guarantee of holding at runtime, assuming previsous formula held)

// BUT supported by instantiation!!!

{ (x = 42) }
assert (x != 0);
{ (x = 42) }
\end{verbatim}
% instead, make rules deterministic and inherently sound
% => they might still not be optimal (we will define measure), but at least verifier is not to blame
% => about non-optimality formalism is to blame, not some inference mechanism (conflict of interest! formulas as strong as possible, verifier as “good”/successful as possible)
% => whether “working” intermediate formula exists is generally not even decidable! (already follows from satisfiability itself not being decidable...)

\begin{align*}
\funHoare_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoare_s = \funHoareC_s \circ \funHoareB_s \circ \funHoareA_s\\
\funHoare_s(\pb{\phi}) = \funHoareC_s(\pb{\phi}) \quad\text{ if $\funHoareApred(s) \wedge \pb{\phi} \implies \funHoareBimp(s)$} \\
\funHoareA_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoareA_s(\pb{\phi}) = \pb{\phi} \quad\text{ if $\funHoareApred(s)$} \\
\funHoareB_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoareB_s(\pb{\phi}) = \pb{\phi} \quad\text{ if $\pb{\phi} \implies \funHoareBimp(s)$} \\
\funHoareC_s : \setFormulaB \rightarrow \setFormulaB\\
\end{align*}

% example of determinified Hoare rule

% lifting... challenges