
% non-deterministic static hoare rules make “quality of lifting” reasoning hard! if even {a}...{true} is valid statically, how to express/measure “badness” of emitting {a}...{?}
% Hoare rules (in a sound language) GUARANTEE that intermediate formulas hold at runtime 
% non-deterministic gradual hoare rules do NOT guarantee that!

% take burdon of chosing “good” intermediate formulas off verifier:
\begin{verbatim}
{ ? }
x := 2;
{ ? } // too weak, not optimal
assert (x = 3);
\end{verbatim}
\begin{verbatim}
{ ? }
assert (x != 0);
{ (x = 42) } // too strong, “somewhat unsound!!!” (no guarantee of holding at runtime, assuming previsous formula held)

// BUT supported by instantiation!!!

{ (x = 42) }
assert (x != 0);
{ (x = 42) }
\end{verbatim}
% instead, make rules deterministic and inherently sound
% => they might still not be optimal (we will define measure), but at least verifier is not to blame
% => about non-optimality formalism is to blame, not some inference mechanism (conflict of interest! formulas as strong as possible, verifier as “good”/successful as possible)
% => whether “working” intermediate formula exists is generally not even decidable! (already follows from satisfiability itself not being decidable...)

\begin{align*}
\funHoare_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoare_s = \funHoareC_s \circ \funHoareB_s \circ \funHoareA_s\\
\funHoare_s(\pb{\phi}) = \funHoareC_s(\pb{\phi}) \quad\text{ if $\funHoareApred(s) \wedge \pb{\phi} \implies \funHoareBimp(s)$} \\
\funHoareA_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoareA_s(\pb{\phi}) = \pb{\phi} \quad\text{ if $\funHoareApred(s)$} \\
\funHoareB_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoareB_s(\pb{\phi}) = \pb{\phi} \quad\text{ if $\pb{\phi} \implies \funHoareBimp(s)$} \\
\funHoareC_s : \setFormulaB \rightarrow \setFormulaB\\
\end{align*}

% example of determinified Hoare rule

% lifting... challenges