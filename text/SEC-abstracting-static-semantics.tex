With the rules for lifting set up we can apply them to the static verification predicate:
Lifting 
$$\thoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setFormula \times \setStmt \times \setFormula$$
w.r.t. both pre- and postcondition results in a predicate
$$\gthoare {~} {\cdot} {\cdot} {\cdot} ~~~\subseteq~~~ \setGFormula \times \setStmt \times \setGFormula$$

% EXAMPLE with proof

%% what's wrong with this predicate
Recall what soundness means for a static verification system:
Assume that $\thoare {~} {\phi_{pre}} {\overline{s}} {\phi_{post}}$ holds in the static verification system.
Given a program state that satisfies $\phi_{pre}$, soundness guarantees us both that execution won't get blocked when executing $\overline{s}$ (progress) and that the program state satisfies $\phi_{post}$ afterwards (preservation).

Unfortunately, the gradual verification predicate severely violates the preservation property.
While we don't expect progress to still be guaranteed without changes to dynamic semantics, there is no way to “fix” preservation.
Consider a sound static verification system (with an assignment rule and a sequence rule) that allows verifying

\begin{mathpar}
\inferrule* [Right=Seq]
{
    {
        \inferrule* [right=Ass]
        { ~ }
        {
            \thoare {~} {\phiTrue} {\sVarAssign{x}{2}} {\phiEq{x}{2}}
        }
    }\\
    {
        \inferrule* [Right=Ass]
        { ~ }
        {
            \thoare {~} {\phiEq{x}{2}} {\sVarAssign{y}{3}} {\phiEq{x}{2} \wedge \phiEq{y}{3}}
        }
    }
}
{
    \thoare {~} {\phiTrue} {\sVarAssign{x}{2}~\sVarAssign{y}{3}} {\phiEq{x}{2} \wedge \phiEq{y}{3}}
}
\end{mathpar}
With the rules of lifting we can deduce
\begin{align*}
&&\thoare {~} {\phiEq{x}{42}} {\sAssert{\phiNeq{x}{0}}} {\phiEq{x}{42}}&\\
\implies&&
\gthoare {~} {\phiEq{x}{42}} {\sAssert{\phiNeq{x}{0}}} {\phiEq{x}{42}}&\\
\implies&&
\gthoare {~} {\qm} {\sAssert{\phiNeq{x}{0}}} {\phiEq{x}{42}}&
\end{align*}

Apparently the precondition does not restrict the program state before executing the assertion.
Let's assume that we 

In the static system, we are guaranteed that the runtime satisfies a postcondition, given that the precondition should execution
There is something fundamentally wrong with this 



% non-deterministic static hoare rules make “quality of lifting” reasoning hard! if even {a}...{true} is valid statically, how to express/measure “badness” of emitting {a}...{?}
% Hoare rules (in a sound language) GUARANTEE that intermediate formulas hold at runtime 
% non-deterministic gradual hoare rules do NOT guarantee that!

% take burdon of chosing “good” intermediate formulas off verifier:
\begin{verbatim}
{ ? }
x := 2;
{ ? } // too weak, not optimal
assert (x = 3);
\end{verbatim}
\begin{verbatim}
{ ? }
assert (x != 0);
{ (x = 42) } // too strong, “somewhat unsound!!!” (no guarantee of holding at runtime, assuming previsous formula held)

// BUT supported by instantiation!!!

{ (x = 42) }
assert (x != 0);
{ (x = 42) }
\end{verbatim}
% instead, make rules deterministic and inherently sound
% => they might still not be optimal (we will define measure), but at least verifier is not to blame
% => about non-optimality formalism is to blame, not some inference mechanism (conflict of interest! formulas as strong as possible, verifier as “good”/successful as possible)
% => whether “working” intermediate formula exists is generally not even decidable! (already follows from satisfiability itself not being decidable...)

\begin{align*}
\funHoare_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoare_s = \funHoareC_s \circ \funHoareB_s \circ \funHoareA_s\\
\funHoare_s(\pb{\phi}) = \funHoareC_s(\pb{\phi}) \quad\text{ if $\funHoareApred(s) \wedge \pb{\phi} \implies \funHoareBimp(s)$} \\
\funHoareA_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoareA_s(\pb{\phi}) = \pb{\phi} \quad\text{ if $\funHoareApred(s)$} \\
\funHoareB_s : \setFormulaB \rightharpoonup \setFormulaB\\
\funHoareB_s(\pb{\phi}) = \pb{\phi} \quad\text{ if $\pb{\phi} \implies \funHoareBimp(s)$} \\
\funHoareC_s : \setFormulaB \rightarrow \setFormulaB\\
\end{align*}

% example of determinified Hoare rule

% lifting... challenges