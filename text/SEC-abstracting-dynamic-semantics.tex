Let $\gsstep{\cdot}{\cdot} : \setGProgramState \rightharpoonup \setGProgramState$ be a sound gradual lifting of $\sstep{\cdot}{\cdot} : \setProgramState \rightharpoonup \setProgramState$.

\begin{comment}
%% make progress work
TODO when progress definition is final
Progress: Note that premise is tautology.
So we artificially make conclusion true by demanding that lifting is total.
This always works since the lifting can be defined arbitrarily wherever the original function is undefined.
\end{comment}

%% preservation
\begin{mathpar}
    \inferrule* [Right=GPreservation']
    {
        \gthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\sSeq{$\grad{s}$}{\sAssert{$\grad{\phi_2}$}}}{\grad{\phi_2}}
    }
\end{mathpar}
The conclusion is a tautology.

%% preservationX
In case the deterministic lifting approach is used to derive a gradual Hoare logic it is desirable to satisfy the stronger notion of preservation introduced in section \ref{ssec:the-deterministic-approach}:
\begin{mathpar}
    \inferrule* [Right=GDPreservation]
    {
        \dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
\end{mathpar}
This stronger notion allows considering return values of the deterministic lifting as static knowledge.
As illustrated in section \ref{sssec:gradual-verification-illustrated}, such static knowledge can be used for optimizations.

To summarize, \tset{GPreservation'} is sufficient for soundness of the gradual system whereas \tset{GDPreservation} is valuable for optimizations.
In the remainder of this section we will thus determine sufficient criteria for \tset{GDPreservation}.


\begin{comment}

Running example:
$$\dgthoare{~}{\qm}{\sAssert{\phiEq{x}{3}}}{\withqmGen{\phiEq{x}{3}}}$$
holds but not
$$\gtHoare{~}{\qm}{\sAssert{\phiEq{x}{3}}}{\withqmGen{\phiEq{x}{3}}}$$

So far, our definition of $\gsssem$ as a total lifting of $\sssem$ may be to weak, breaking the subset relationship:
\begin{description}
    \item[$\sssem$ too weak]
    It is possible that the dynamic semantics of \svl defines
    $$\sssem^{\sAssert{\phiEq{x}{3}}}(\pi_{\phiEq{x}{4}}) = \pi'_{\phiEq{x}{4}}$$
    This is not unreasonable, since this function is guaranteed to be only called with “valid” program states in the static system!
    An additional runtime check would be overhead.
    
    \item[$\gsssem$ too weak]
    If $\sssem^{\sAssert{\phiEq{x}{3}}}(\pi_{\phiEq{x}{4}})$ is undefined due to runtime checks.
    Yet, the lifting is supposed to be total, so passing along the program state unchecked is again a valid realization:
    $$\gsssem^{\sAssert{\phiEq{x}{3}}}(\pi_{\phiEq{x}{4}}) = \pi'_{\phiEq{x}{4}}$$
    Mapping to an exception would have been better in this case.
\end{description}
Note that both problems are unrelated to optimality of the lifting.

\end{comment}

%% first: changes in source code!!!
% making formula gradual 
% - cannot let execution fail 
% - cannot satisfy less formulas (“observational compatibility”})