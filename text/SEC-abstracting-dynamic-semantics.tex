Let $\gsssem : \setGProgramState \rightharpoonup \setGProgramState$ be a sound gradual lifting of $\sssem : \setProgramState \rightharpoonup \setProgramState$.

%% make progress work
TODO when progress definition is final
Progress: Note that premise is tautology.
So we artificially make conclusion true by demanding that lifting is total.
This always works since the lifting can be defined arbitrarily wherever the original function is undefined.

%% preservation
\begin{mathpar}
    \inferrule* [Right=GPreservation']
    {
        \gthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\sSeq{$\grad{s}$}{\sAssert{$\grad{\phi_2}$}}}{\grad{\phi_2}}
    }
\end{mathpar}
Conclusion is a tautology.

%% preservationX
In case the deterministic lifting approach was used to derive a gradual Hoare logic it is desirable to satisfy the stronger notion of preservation introduced in section \ref{ssec:the-deterministic-approach}.
\begin{mathpar}
    \inferrule* [Right=GDPreservation]
    {
        \dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
\end{mathpar}
Satisfying this rule is theoretically not necessary as injecting assertions \tset{GPreservation'} suffices 


This is not really satisfying: 
An arbitrary verification predicate would satisfy this kind of preservation.
Also, this is no guarantee for all the formulas describing intermediate program states.
A stronger notion of preservation gives this guarantee:
\begin{mathpar}
    \inferrule* [Right=GPreservation]
    {
        \dgthoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
    {
        \gtHoare{~}{\grad{\phi_1}}{\grad{s}}{\grad{\phi_2}}
    }
\end{mathpar}

Making this guarantee work is trickier and there are different trade-offs available.
Without further assumptions, $\dgthoare{~}{\cdot}{\cdot}{\cdot}$ is not a subset of $\gtHoare{~}{\cdot}{\cdot}{\cdot}$.

Running example:
$$\dgthoare{~}{\qm}{\sAssert{\phiEq{x}{3}}}{\withqmGen{\phiEq{x}{3}}}$$
holds but not
$$\gtHoare{~}{\qm}{\sAssert{\phiEq{x}{3}}}{\withqmGen{\phiEq{x}{3}}}$$

So far, our definition of $\gsssem$ as a total lifting of $\sssem$ may be to weak, breaking the subset relationship:
\begin{description}
    \item[$\sssem$ too weak]
    It is possible that the dynamic semantics of \svl defines
    $$\sssem^{\sAssert{\phiEq{x}{3}}}(\pi_{\phiEq{x}{4}}) = \pi'_{\phiEq{x}{4}}$$
    This is not unreasonable, since this function is guaranteed to be only called with “valid” program states in the static system!
    An additional runtime check would be overhead.
    
    \item[$\gsssem$ too weak]
    If $\sssem^{\sAssert{\phiEq{x}{3}}}(\pi_{\phiEq{x}{4}})$ is undefined due to runtime checks.
    Yet, the lifting is supposed to be total, so passing along the program state unchecked is again a valid realization:
    $$\gsssem^{\sAssert{\phiEq{x}{3}}}(\pi_{\phiEq{x}{4}}) = \pi'_{\phiEq{x}{4}}$$
    Mapping to an exception would have been better in this case.
\end{description}
Note that both problems are unrelated to optimality of the lifting.

%% first: changes in source code!!!
% making formula gradual 
% - cannot let execution fail 
% - cannot satisfy less formulas (“observational compatibility”})