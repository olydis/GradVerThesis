Formula semantics of \svlidf only depend on the heap and on the top most stack frame of a program state (more specifically: the local variable environment and the accessible fields, but not the continuation statement).
To drastically simplify notation, we will therefore define $\vDash \subseteq \setProgramState \times \setFormula$ (as postulated in section \ref{sec:a-statically-verified}) indirectly:
\begin{mathpar}
    \inferrule* [Right=EvalFrm]
    {
        \evalphi {\phi}
    }
    {
        \evalphiGen{(H, (\rho, A, s) \cdot S)}{\phi}
    }
\end{mathpar}

Figure \ref{fig:svl-evalphi} defines the actual semantics as a predicate $\vDash \subseteq \setHeap \times \setVarEnv \times \setDFootprint \times \setFormula$.
\begin{figure}
    \boxed{\evalphi \phi}
    \input{data/svl-sem-dyn-form}
    \caption{\svlidf: Evaluating Formulas}
    \label{fig:svl-evalphi}
\end{figure}

% TODO: subtelties of EAAcc?
% SEPOp



% RULES arising from this semantics!!! e.g. implication:
% - a * b => a
% - a !=> a * a