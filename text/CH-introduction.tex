%% program verification
Program verification aims to check a compute program against its specification.
Automated methods require this specification to be formalized, for example using annotations or assertions in the source code.
Common examples are method contracts and loop invariants.
% Successfully verified programs are guaranteed to comply with  

%% static vs dynamic
There are a variety of approaches to check whether the program behavior complies with given annotations.
They can usually be divided into two categories:\\
\begin{tabular}{l | c | c}
     & Static verification & Dynamic verification \\ \hline
    Approach &
    \begin{minipage}{170pt}
        \vspace{3pt}
        The program is not executed. 
        Instead \textbf{formal methods} (like Hoare logic) are used, trying to derive a proof for given assertions.
        \vspace{5pt}
    \end{minipage}
    &
    \begin{minipage}{170pt}
        \vspace{3pt}
        The specification is turned into \textbf{runtime checks}, making sure that the program adheres to its specification during execution.
        Violations cause a runtime exception to be thrown, effectively preventing the program from entering a state that contradicts its specification.
        Note that in practice this approach is often combined with control flow based testing techniques to detect misbehavior as early as possible.
        \vspace{5pt}
    \end{minipage}\\\hline
    Drawbacks &
    \begin{minipage}{170pt}
        \vspace{3pt}
        The syntax available for static verification is naturally limited by the underlying formal logic.
        Complex conditions/behavior might thus not be expressible, resulting in inability to prove subsequent properties.
        Furthermore, the logic itself might be unable to prove certain properties due to complex behavior of the code and undecidability in general.
        Using static verification usually requires rigorous annotation of the entire source code, as otherwise there might be too little information to find a proof.
        While adding such annotations to own code can be tedious (yet, there are supporting tools), using unannotated libraries can become a problem:
        Even if it is possible to add own annotations, lacking the source code, the verifier is unable to prove those annotations, resulting in inconsistent proves in case the annotation turns out to be wrong.
        \vspace{5pt}
    \end{minipage}
    &
    \begin{minipage}{170pt}
        \vspace{3pt}
        Violations are only detected at runtime, with the risk of going unnoticed before software is released.
        To minimize this risk, testing methods are required, i.e. more time has to be spent after compilation.
        The usage of runtime checks naturally imposes a runtime overhead which is not always acceptable.
        % To get rid of 
        \vspace{5pt}
    \end{minipage}\\\hline
\end{tabular}

Most modern programming languages use static methods to some degree, ruling out at least some types of runtime failure.
%% static typing
Static typing disciplines are among the most common representatives, guaranteeing type safety at compile time, obviating the need for dynamic checks.
Yet, the rigidity and limitations of static type systems resulted in the introduction of dynamic aspects into the otherwise static system:
Casts (e.g. as implemented in C\# or Java) overrule purely static reasoning, allowing the static type system to treat an expression as if it had the claimed type (usually a subtype) instead of the deduced one.
At this location, a dynamic check is introduced, resulting in a cast exception should the programmer's claim turn out wrong.
Note that the necessity of casts is only due one of the drawbacks of static verification, namely the limitation of formal logic.
More sophisticated type systems (e.g. the one in Haskell) might have been able to deduce the claimed type in the first place.

%% static verification
In contrast, general purpose static verification techniques are not common amongst popular programming languages.
Note that such languages are usually driven by cost-benefit and usability considerations, meaning that static verification is apparently not yet in a stage where its cost clearly outweighs its benefits.


%% static verification
% example?
These limitations not only affect programmers trying to statically verify their program.
Most general purpose programming languages (C/C++, C\#, Java, ...), usually driven by cost-benefit and usability considerations, haven't adopted this level of static analysis in the first place.

%% grad verification
The purpose of gradual verification is to weaken if not remove some of these limitations at the cost of turning some static checks into runtime checks, whenever inevitable.
We will present a procedure of turning a static verification into a gradual one.
% more detail about static limitations and how runtime circumvents them?

%% static typing weakened
This idea is not new at all and actually common practice in type systems:
In C\# or Java, explicit type casts are assertions about the actual type of a value.
This actual type (usually a subtype of the statically known type) could not be deduced by the static type system due to its limitations.
Such an assertion/cast allows subsequent static reasoning about the value assuming its new type at the cost of an additional runtime check, ensuring the validity of the cast.
Note that such deviations from a “purely” static type system (one where there is no need for runtime checks) do not affect type safety:
It is still guaranteed that execution does not enter an invalid state (one where runtime types are incompatible with statically annotated types) by simply interrupting execution whenever a runtime type check fails.
This is usually implemented by throwing an exception.
% mention that runtime cost reasonable, ...


%% dyn typing
At the other end of the spectrum are dynamically typed languages.
In scenarios where the limitations of a static type system would clutter up the source code, they allow expressing the same logic with less syntactic overhead, but at the cost of less static guarantees and early bug detection.

%% PLs are on the dynamic end of the verification spectrum
In terms of program verification, most general purpose languages are on the dynamic end of the spectrum.
If they exist as designated syntax, assertions are usually implemented as runtime checks and often even dropped entirely for “release” builds (the Java compiler drops them by default).
It is common practice to implement 
% research Eiffel!
% Design-by-Contract!!! Eiffel!
% D even has both

% this is more of a consequence of the “deep roots” of dynamic verification!!!
%But even preconditions at expression level are implemented as runtime checks, reflected all the way down at instruction architecture level.
%Examples:
%\begin{description}
%    \item[Division by zero]~\\
%    Integer division performs a dynamic check...
%    
%\end{description}

%% grad typing
A gradual type system is more flexible, as it provides the full continuum between static and dynamic typing, letting the programmer decide ... %TODO.
It can be seen as an extension  “unknown” type 


This work will also show that gradual verification ... other angle!

- 
What is the thesis about?
Why is it relevant or important?
What are the issues or problems?
What is the proposed solution or approach?
What can one expect in the rest of the thesis?

“Static verification checks that properties are always true, but it can be difficult and tedious to select a goal and to annotate programs for input to a static checker.” (http://www.sciencedirect.com/science/article/pii/S1571066104002567)
