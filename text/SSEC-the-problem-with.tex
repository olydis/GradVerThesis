%% Intro
%As seen in section \ref{ssec:gradual-soundness}, the lifted Hoare predicate in general requires an additional runtime assertion to guarantee soundness.
In case the Hoare rules of \svl are given inductively, we can make use of the rules for composite, disjunctive and conjunctive predicate lifting (see section \ref{sssec:examples-lift-predicates}).
The rules allow us to soundly lift each individual inductive rule in order to end up with a sound lifting of the overall predicate.

%% example
\begin{example}{Rule-wise Hoare Logic Lifting}
    Given:
    \begin{mathpar}
        \inferrule* [right=HSeq]
        {
            \phiImplies{\phi_{q1}} {\phi_{q2}} \\\\
            \thoare {} {\phi_p} {{s_1}} {\phi_{q1}} \\
            \thoare {} {\phi_{q2}} {{s_2}} {\phi_r}
        }
        {
            \thoare {} {\phi_p} {\sSeq{$s_1$}{$s_2$}} {\phi_r}
        }
        
        \inferrule* [Right=HAssign]
        {
            ~
        }
        {
            \thoare {} {\phi[e/x]} {\sVarAssign{$x$}{$e$}} {\phi}
        }
    \end{mathpar}
    Rule-wise lifting:
    \begin{mathpar}
        \inferrule* [right=\gradT HSeq]
        {
            \gphiImplies{\grad{\phi_{q1}}} {\grad{\phi_{q2}}} \\\\
            \gthoare {} {\grad{\phi_p}} {{s_1}} {\grad{\phi_{q1}}} \\
            \gthoare {} {\grad{\phi_{q2}}} {{s_2}} {\grad{\phi_r}}
        }
        {
            \gthoare {} {\grad{\phi_p}} {\sSeq{$s_1$}{$s_2$}} {\grad{\phi_r}}
        }
        
        \inferrule* [right=\gradT HAssign1]
        {
            ~
        }
        {
            \gthoare {} {\phi[e/x]} {\sVarAssign{$x$}{$e$}} {\phi}
        }
        
        \inferrule* [right=\gradT HAssign2]
        {
            ~
        }
        {
            \gthoare {} {\qm} {\sVarAssign{$x$}{$e$}} {\grad{\phi}}
        }
        
        \inferrule* [right=\gradT HAssign3]
        {
            ~
        }
        {
            \gthoare {} {\grad{\phi}} {\sVarAssign{$x$}{$e$}} {\qm}
        }
    \end{mathpar}
    
    Note the usage of composite predicate lifting (lemma \ref{lemma:pred-lift-comp}) for \tset{\gradT HSeq}.
\end{example}

%% example descr
% The overall Hoare predicate $\thoare {} {\cdot} {\cdot} {\cdot}$ can be thought of as a disjunction of all inductive rules.
% It follows that $\gthoare {} {\cdot} {\cdot} {\cdot}$, being the disjunction of above lifted rules is also a sound lifting.

%% theory vs verifier practice (many choices)
Unfortunately, a gradual verifier using $\gthoare {} {\cdot} {\cdot} {\cdot}$ gets into a practical dilemma.
Consider the Hoare triple
\begin{displaymath}
\hoare{\qm}{\sSeq{\sVarAssign{y}{2}}{\sVarAssign{x}{3}}}{\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}
\end{displaymath}
It is the job of the gradual verifier to prove the triple using above gradual inductive rules.
Using rule inversion (rule \tset{\gradT HSeq}) it can deduce that 
\begin{gather*}
\gphiImplies{\grad{\phi_{q1}}} {\grad{\phi_{q2}}} \\
\gthoare {} {\qm} {\sVarAssign{y}{2}} {\grad{\phi_{q1}}} \\
\gthoare {} {\grad{\phi_{q2}}} {\sVarAssign{x}{3}} {\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}
\end{gather*}
has to hold for some $\grad{\phi_{q1}}, \grad{\phi_{q2}} \in \setGFormula$.
There are a variety of valid instantiations for both variables:
\begin{description}
    \item[Good: $\grad{\phi_{q1}} = \phiEq{y}{2},~ \grad{\phi_{q2}} = \phiEq{y}{2}$]~\\
    This instantiation aims to use static formulas as early as possible.
    The implication trivially holds.
        
    \item[Too weak: $\grad{\phi_{q1}} = \qm,~ \grad{\phi_{q2}} = \qm$]~\\
    Whenever there exists a valid instantiation at all, the wildcard is also a valid one, so always choosing it would be an easy way of implementing a gradual verifier.
    Note however, that the knowledge about the first statement is lost which results in the necessity of dynamic checks to ensure $\phiEq{x}{3}$ after $\sVarAssign{y}{2}$.
    Before, this check could have been optimized away.
    In general, choosing $\qm$ as intermediate gradual formulas allows verifying arbitrary inconsistent judgments (a manifestation of the lack of optimality of $\gthoare {} {\cdot} {\cdot} {\cdot}$).
    
    \begin{example}{Inconsistent Gradual Verification}
        \begin{displaymath}
        \gthoare{}{\phiTrue}{\sSeq{\sVarAssign{y}{2}}{\sVarAssign{x}{3}}}{\phiEq{y}{100}}
        \end{displaymath}
        is verifiable if the gradual verifier chooses $\qm$ as intermediate gradual formulas.
    \end{example}
    
    Consequently, the verifier may try to be “as precise as possible” in order to detect inconsistencies at compile time.
        
    \item[Too strict: $\grad{\phi_{q1}} = \phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}},~ \grad{\phi_{q2}} = \phiEq{y}{2}$]~\\
    This instantiation is fully static, i.e. precise.
    
    However, the instantiation is stricter than necessary -- but nevertheless valid according to the rules.
    The implication holds (the knowledge about \ttt{x} is dropped), and $$\gthoare {} {\qm} {\sVarAssign{y}{2}} {\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}$$ holds since $$\thoare {} {\phiAnd{\phiEq{x}{3}}{\phiEq{2}{2}}} {\sVarAssign{y}{2}} {\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}$$ does.
    
    This instantiation illustrates the requirement of runtime checks to ensure soundness as described in section \ref{ssec:gradual-soundness}.
    The judgment $\gthoare {} {\qm} {\sVarAssign{y}{2}} {\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}$ must lead to the injection of an assertion of $\sAssert{\phiAnd{\phiEq{x}{3}}{\phiEq{y}{2}}}$ right after the assignment.
    Unfortunately, this assertion alters runtime behavior:
    Code that would have never thrown an exception when evaluated with the runtime of \svl might now throw an exception.
    This is a violation of the dynamic gradual guarantee (note that we are still designing the static system, so no violation).
    Note that it is actually the runtime semantics breaking the guarantee, yet it is the “bad decision” made by the verifier that leads up to it.
    
    Consequently, further rules are necessary to prevent the verifier from making decisions that are, as in this case, not general.
\end{description}

%% comparison: static verifier
Note that above observations do not apply to a static verifier as the former two cases above rely on the existence of the wildcard:
The weak instantiation is syntactically impossible, the too strict instantiation relied on the fact that the precondition (of the overall judgment) is a wildcard.

%% dilemma, consequence
On the other hand, decisions of the gradual verifier have the power to change the runtime behavior or let obvious inconsistencies go unnoticed.
We propose a different approach, resulting in a deterministic gradual Hoare logic which also obviates the need of injecting runtime assertions.



