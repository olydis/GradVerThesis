% IDEA: separate theoretical/general approach and concrete decisions
% this means, for example, that:
% PART1:
% - requirements for lifted functions, soundness
% - implication (gradual, ...)
% - abstract versions of [w/o], append
% PART2:
% - concrete version of [w/o], append, ... (probably requires notion of normalized env :( )
% - actual implementation

\chapter{Introduction}
Most modern programming languages use static analysis to some degree, ruling out certain types of runtime failure.
Static analysis provides guarantees about the dynamic behavior of a program without actually running the program.
%% static typing
Static typing disciplines are among the most common representatives of static analysis, guaranteeing type safety at compile time, obviating the need for dynamic checks.

%% static verification
Another powerful technique is static verification of programs against their specification, i.e. statically proving their “correctness”.
In practice this is achieved by checking that some annotated invariants or assertions (reflecting the specification) must always hold.
% example?
Unfortunately, static verification has limitations and drawbacks:
\begin{itemize} % TODO
    \item Syntax
    \item Decidability
    \item Difficult and Tedious to annotate programs
    \item ...
\end{itemize}
These limitations not only affect programmers trying to statically verify their program.
Most general purpose programming languages (C/C++, C\#, Java, ...), usually driven by cost-benefit and usability considerations, haven't adopted this level of static analysis in the first place.

%% grad verification
The purpose of gradual verification is to weaken if not remove some of these limitations at the cost of turning some static checks into runtime checks, whenever inevitable.
We will present a procedure of turning a static verification into a gradual one.
% more detail about static limitations and how runtime circumvents them?

%% static typing weakened
This idea is not new at all and actually common practice in type systems:
In C\# or Java, explicit type casts are assertions about the actual type of a value.
This actual type (usually a subtype of the statically known type) could not be deduced by the static type system due to its limitations.
Such an assertion/cast allows subsequent static reasoning about the value assuming its new type at the cost of an additional runtime check, ensuring the validity of the cast.
Note that such deviations from a “purely” static type system (one where there is no need for runtime checks) do not affect type safety:
It is still guaranteed that execution does not enter an invalid state (one where runtime types are incompatible with statically annotated types) by simply interrupting execution whenever a runtime type check fails.
This is usually implemented by throwing an exception.
% mention that runtime cost reasonable, ...


%% dyn typing
At the other end of the spectrum are dynamically typed languages.
In scenarios where the limitations of a static type system would clutter up the source code, they allow expressing the same logic with less syntactic overhead, but at the cost of less static guarantees and early bug detection.

%% PLs are on the dynamic end of the verification spectrum
In terms of program verification, most general purpose languages are on the dynamic end of the spectrum.
If they exist as designated syntax, assertions are usually implemented as runtime checks and often even dropped entirely for “release” builds (the Java compiler drops them by default).
It is common practice to implement 
% research Eiffel!
% Design-by-Contract!!! Eiffel!
% D even has both

% this is more of a consequence of the “deep roots” of dynamic verification!!!
%But even preconditions at expression level are implemented as runtime checks, reflected all the way down at instruction architecture level.
%Examples:
%\begin{description}
%    \item[Division by zero]~\\
%    Integer division performs a dynamic check...
%    
%\end{description}

%% grad typing
A gradual type system is more flexible, as it provides the full continuum between static and dynamic typing, letting the programmer decide ... %TODO.
It can be seen as an extension  “unknown” type 


This work will also show that gradual verification ... other angle!

- 
What is the thesis about?
Why is it relevant or important?
What are the issues or problems?
What is the proposed solution or approach?
What can one expect in the rest of the thesis?

“Static verification checks that properties are always true, but it can be difficult and tedious to select a goal and to annotate programs for input to a static checker.” (http://www.sciencedirect.com/science/article/pii/S1571066104002567)


\section{Motivation}
more practical view? Intro? Background?



\chapter{Background}

\section{Categorization of existing stuff}
\cite{nelson2004extended} ESC/Java
Software development and maintenance are costly endeavors.
The cost can be reduced if more software defects are
detected earlier in the development cycle. This paper introduces
the Extended Static Checker for Java (ESC/Java),
an experimental compile-time program checker that finds
common programming errors. The checker is powered by
verification-condition generation and automatic theoremproving
techniques. It provides programmers with a simple
annotation language with which programmer design decisions
can be expressed formally. ESC/Java examines the
annotated software and warns of inconsistencies between the
design decisions recorded in the annotations and the actual
code, and also warns of potential runtime errors in the code.
This paper gives an overview of the checker architecture and
annotation language and describes our experience applying
the checker to tens of thousands of lines of Java programs.

\cite{jacobs2001logic} JML => static verification

\cite{cheon2002runtime} JML => RAC

\cite{the-spec-programming-system-an-overview} Spec\#

\cite{a-statically-verifiable-programming-model-for-concurrent-object-oriented-programs} Spec\# extension (concurrent OO)

\cite{embedded-contract-languages} Code Contracts! Combines runtime and static checking

\section{Hoare Logic}
...for static semantics

\section{Related Work}
\subsection{Abstract Gradual Typing}

\subsection{Implicit Dynamic Frames}
% separating conjuction (= Multiplicative conjunction ⊗, lollipop, ...), access is resource, cannot duplicate access, ...
% TODO: explain Frame Problem
% translation of separating conjuction to regular conjunction? would simplify later reasoning A LOT

\subsubsection{Self-Framing}



%STRUCTURE:
% - intruduce static sample language (interesting for IDF, blabla, ..., but also general enough to transfer ideas)
% - gradualize sample language without focus on impl. details (assume NPC/undec. sat, impl, ... to stay general), i.e. focus on principal correctness
% - implement this very language and show effects of precision, ...


\chapter{Gradualization of a static... / A Statically Verified Language}
%% why start with static language
As illustrated earlier %MAKE SURE!
gradual verification can be seen as an extension of both static and dynamic verification.
% Both can be seen as the endpoints of the continuum...?
Yet, our approach of “gradualization” formalizes the introduction of the dynamic aspect into a fully static system.
Thus, this %TODO: work, section, chapter?
uses a statically verified language as starting point.
Later %TODO: ref
we will show how a programming language without static verification can be approached.

%% more about our language
We will now intrude a very simple Java-like language that uses Chalice/Eiffel/Spec\# %???
 sub-syntax to express method contracts.
% more about simplicity?

%% structure of this chapter
% TODO

\section{A Statically Verified Language}
\label{sec:a-statically-verified}
\input{text/SEC-a-statically-verified}

\subsection{Syntax}
\label{sec:syntax}
\input{text/SEC-syntax}

\subsection{Static Semantics}
\label{sec:static-semantics}
\input{text/SEC-static-semantics}

\subsection{Well-Formedness}
\label{sec:well-formedness}
\input{text/SEC-well-formedness}

\subsection{Dynamic Semantics}


\section{Deriving a Gradually Verified Language}

\subsection{Abstracting Static Semantics}

\subsection{Abstracting Dynamic Semantics}


\chapter{Implementation}
...of \ref{sec:a-statically-verified}

\section{Prepare Hoare Rules}
% make deterministic, split into 3 sections

\subsection{Deterministic Functions}

\section{Gradualize Hoare Rules}

\subsection{Gradualize Functions}
% IDF stuff will probably only show up here!

\section{Enhancing an Unverified Language}


\chapter{Evaluation/Analysis}
> E:
with gradual typestates the same problem happened: as soon as the potential for unknown annotations was accepted, there was a “baseline cost” just to maintain the necessary infrastructure.
With simple gradual types, it’s almost nothing. With gradual effects, we’ve shown that it can boil down to very little (a thread-local variable with little overhead, see OOPSLA’15). 


\chapter{Conclusion}
Recap, remind reader what big picture was.
Briefly outline your thesis, motivation, problem, and proposed solution.

\section{Limitations}

\section{Future Work}


\chapter{Appendix}


\chapter{UNSORTED}

\section{HoareMotivEx}
\label{sec:hoaremotivex}
\input{text/SEC-hoaremotivex}

\section{MotivationExamples}
\label{sec:motivationexamples}
\input{text/SEC-motivationexamples}
