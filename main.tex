\documentclass[11pt,a4paper]{scrbook}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage[margin=1.2in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{syntax}
\usepackage{lscape}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{newunicodechar}
\usepackage{xspace}
\usepackage[labelsep=period, labelfont=bf]{caption}

\makeatletter
\newcommand*{\shifttext}[2]{%
    \settowidth{\@tempdima}{#2}%
    \makebox[\@tempdima]{\hspace*{#1}#2}%
}
\makeatother

\newunicodechar{≠}{=\llap{/}}
\newunicodechar{≔}{:\raisebox{-0.18ex}[\height][\depth]{=}}
\newunicodechar{∧}{\shifttext{0.4ex}{/}\shifttext{-0.4ex}{\textbackslash}}

% CODE LISTINGS

\definecolor{cogreen}{RGB}{0,80,0}
\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    commentstyle=\ttfamily,
    frame=single,
    framesep=5pt,
    mathescape=true,
    %escapeinside={(*}{*)},
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{darkgray}\ttfamily,
    commentstyle=\color{cogreen}\ttfamily,
    morekeywords={requires, ensures}
}

% THEOREMS
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}

% BIB
\bibliographystyle{plain}

% COMMANDS
% \DeclareMathSymbol{\mlq}{\mathord}{operators}{``}
% \DeclareMathSymbol{\mrq}{\mathord}{operators}{`'}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}

%% decoration
\newcommand{\pa}[1]{\ensuremath{{#1}^{\checkmark}}}
\newcommand{\pb}[1]{\ensuremath{{#1}^{\circ}}}

\newcommand{\grad}[1]{\widetilde{#1}}
\newcommand{\dgrad}[1]{\vec{#1}}

%% ALIASES
% fonts
\newcommand{\std}{\textrm}
\newcommand{\ttt}{\texttt}
\newcommand{\tset}{\textsc}
\newcommand{\predicate}[1]{\textup{\textsf{#1}}}
% names
\newcommand{\gsvl}{\std{GSVL}\xspace}
\newcommand{\svl}{\std{SVL}\xspace}
\newcommand{\dvl}{\std{DVL}\xspace}
\newcommand{\gvl}{\std{GVL}\xspace}

% sets
\newcommand{\setProgramState}{\tset{ProgramState}\xspace}
\newcommand{\setProgramStateFin}{\tset{ProgramStateFin}\xspace}
\newcommand{\setProgramStateEx}{\tset{ProgramStateEx}\xspace}
\newcommand{\setGProgramState}{\tset{GProgramState}\xspace}
\newcommand{\setGProgramStateFin}{\tset{GProgramStateFin}\xspace}
\newcommand{\setGProgramStateEx}{\tset{GProgramStateEx}\xspace}
\newcommand{\setProgram}{\tset{Program}\xspace}
\newcommand{\setGProgram}{\tset{GProgram}\xspace}
\newcommand{\setClass}{\tset{Class}\xspace}
\newcommand{\setField}{\tset{Field}\xspace}
\newcommand{\setMethod}{\tset{Method}\xspace}
\newcommand{\setGMethod}{\tset{GMethod}\xspace}
\newcommand{\setContract}{\tset{Contract}\xspace}
\newcommand{\setGContract}{\tset{GContract}\xspace}
\newcommand{\setType}{\tset{Type}\xspace}
\newcommand{\setStmt}{\tset{Stmt}\xspace}
\newcommand{\setGStmt}{\tset{GStmt}\xspace}
\newcommand{\setStmts}{\tset{Stmts}\xspace} %TODO!!!
\newcommand{\setFormula}{\tset{Formula}\xspace}
\newcommand{\setFormulaA}{\tset{SatFormula}\xspace}
\newcommand{\setFormulaB}{\tset{SfrmFormula}\xspace}
\newcommand{\setGFormula}{\tset{GFormula}\xspace}
\newcommand{\setGFormulaA}{\tset{SatGFormula}\xspace}
\newcommand{\setGFormulaB}{\tset{SfrmGFormula}\xspace}
\newcommand{\setExpr}{\tset{Expr}\xspace}
\newcommand{\setVal}{\tset{Val}\xspace}
\newcommand{\setObj}{\tset{Obj}\xspace}
\newcommand{\setVar}{\tset{Var}\xspace}

\newcommand{\setHeap}{\tset{Heap}\xspace}
\newcommand{\setStack}{\tset{Stack}\xspace}
\newcommand{\setStackEntry}{\tset{StackEntry}\xspace}
\newcommand{\setVarEnv}{\tset{VarEnv}\xspace}
\newcommand{\setTypeEnv}{\tset{TypeEnv}\xspace}
\newcommand{\setClassName}{\tset{ClassName}\xspace}
\newcommand{\setFieldName}{\tset{FieldName}\xspace}
\newcommand{\setMethodName}{\tset{MethodName}\xspace}
\newcommand{\setSFootprint}{\tset{StaticFootprint}\xspace}
\newcommand{\setDFootprint}{\tset{DynamicFootprint}\xspace}
% expressions
\newcommand{\ev}[1]{\ttt{#1}}
\newcommand{\ex}[1]{\ttt{#1}}
\newcommand{\edot}[2]{\ttt{#1.#2}}
\newcommand{\ethis}{\ex{this}}
\newcommand{\eresult}{\ex{result}}
\newcommand{\enull}{\ttt{null}}
% formulas
\newcommand{\phiAnd}[2]{\ttt{#1\:∧\:#2}}
\newcommand{\phiCons}[2]{\ttt{#1\:*\:#2}}
\newcommand{\phiFalse}[0]{\ttt{false}}
\newcommand{\phiTrue}[0]{\ttt{true}}
\newcommand{\phiEq}[2]{\ttt{(#1 = #2)}}
\newcommand{\phiNeq}[2]{\ttt{(#1 ≠ #2)}}
\newcommand{\phiAcc}[2]{\ttt{acc(#1.#2)}}
\newcommand{\qm}{\ttt{?}}
\newcommand{\withqm}[1]{\phiCons{\qm}{\ensuremath{#1}}}
\newcommand{\withqmGen}[1]{\phiAnd{\ensuremath{#1}}{\qm}}
% statements
\newcommand{\sSkip}{\ttt{skip}}
\newcommand{\sFieldAssign}[3]{\ttt{#1.#2 ≔ #3}}
\newcommand{\sVarAssign}[2]{\ttt{#1 ≔ #2}}
\newcommand{\sAlloc}[2]{\ttt{#1 ≔ new #2}}
\newcommand{\sCall}[4]{\ttt{#1 ≔ #2.#3(#4)}}
\newcommand{\sReturn}[1]{\ttt{return #1}}
\newcommand{\sAssert}[1]{\ttt{assert #1}}
\newcommand{\sRelease}[1]{\ttt{release #1}}
\newcommand{\sDeclare}[2]{\ttt{#1~#2}}
\newcommand{\sHold}[2]{\ttt{hold #1~\{ #2 \}}}
\newcommand{\sSeq}[2]{\ttt{{#1};{#2}}}
% type
\newcommand{\type}[1]{\ttt{#1}}
\newcommand{\Tint}{\type{int}}
% composite syntax
\newcommand{\class}[3]{\ttt{class {#1}~\{ {#2} {#3} \}}}
\newcommand{\method}[6]{\ttt{{#1}~{#2}({#3}~{#4})~{#5}~\{ {#6} \}}}
\newcommand{\contract}[2]{\ttt{requires {#1}; ensures {#2};}}
\newcommand{\field}[2]{\ttt{{#1}~{#2};}}
%% predicates
% precision
\newcommand{\mpt}{\sqsubseteq}
\newcommand{\mptpi}{\sqsubseteq_{\pi}}
% well-formed
\newcommand{\wsp}{\predicate{wsp}}
\newcommand{\verify}{\predicate{verify}}
\newcommand{\OK}{~\predicate{OK}}
\newcommand{\OKinC}{~\predicate{OK in}~C}
% framing
\newcommand{\sfrme}{\ensuremath{\vdash_\texttt{frm}}\,}
\newcommand{\sfrmphi}{\ensuremath{\vdash_\texttt{sfrm}}\,}
% evaluation
\newcommand{\evalex}[4]{#1,#2 \vdash #3 \Downarrow #4}
\newcommand{\evale}[2]{H,\rho \vdash #1 \Downarrow #2}
\newcommand{\evalphiXGen}[2]{#1 \vDash_{X} #2}
\newcommand{\evalgphiXGen}[2]{#1 \,\,\grad{\vDash_{X}}\,\, #2}
\newcommand{\evalphiGen}[2]{#1 \vDash #2}
\newcommand{\evalgphiGen}[2]{#1 \,\,\grad{\vDash}\,\, #2}
\newcommand{\evalphi}[1]{\evalphiGen {H,\rho,A} {#1}}
\newcommand{\evalgphi}[1]{\evalgphiGen {H,\rho,A} {#1}}
\newcommand{\phiImplies}[2]{{#1} \underset{\phi}{\implies} {#2}}
\newcommand{\gphiImplies}[2]{{#1} \,\,\underset{\phi}{\grad{\implies}}\, {#2}}
\newcommand{\evalphix}[4]{\evalphiGen {#1,#2,#3} {#4}}
% extraction
\newcommand{\fieldType}{\predicate{fieldType$_p$}}
\newcommand{\fields}{\predicate{fields$_p$}}
\newcommand{\mpre}{\predicate{mpre$_p$}}
\newcommand{\mpost}{\predicate{mpost$_p$}}
\newcommand{\mmethod}{\predicate{method$_p$}}
% other
\newcommand{\static}{\predicate{static}}
\newcommand{\dom}{\predicate{dom}}
\newcommand{\writesTo}{\predicate{writesTo}}
\newcommand{\sType}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\defaultValue}[1]{\predicate{defaultValue(#1)}}
\newcommand{\defeq}{\overset{\predicate{def}}{=}}
\newcommand{\defiff}{\overset{\predicate{def}}{\iff}}
\newcommand{\accFor}[1]{\llbracket #1 \rrbracket}
% footprint
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
\newcommand{\staticFP}[1]{\ensuremath{\floor{#1}}}
\newcommand{\dynamicFP}[3]{\ensuremath{\floor{#3}_{#1,#2}}}
% static sem
\newcommand{\hoare}[3]{\{{#1}\} ~{#2}~ \{{#3}\}}
\newcommand{\thoare}[4]{{#1} \vdash \{{#2}\} ~{#3}~ \{{#4}\}}
\newcommand{\gthoare}[4]{{#1} \,\,\grad{\vdash}\,\, \{{#2}\} ~{#3}~ \{{#4}\}}
\newcommand{\dgthoare}[4]{{#1} \,\,\dgrad{\vdash}\,\, \{{#2}\} ~{#3}~ \{{#4}\}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\sssem}{\mathcal{S}}
\newcommand{\gsssem}{\grad{\sssem}}
\newcommand{\funHoare}{\mathcal{H}}
\newcommand{\funHoareA}{\mathcal{F}}
\newcommand{\funHoareApred}{\mathcal{P}}
\newcommand{\funHoareB}{\mathcal{I}}
\newcommand{\funHoareBimp}{\mathcal{J}}
\newcommand{\funHoareC}{\mathcal{M}}
% dyn sem
\newcommand{\progress}{\predicate{progress}_{\sssem}}
\newcommand{\sstepGeneric}[5]{({#1}, {#2}) \rightarrow^{#3} ({#4}, {#5})}
\newcommand{\sstep}[4]{\sstepGeneric {#1} {#2} {} {#3} {#4}}
\newcommand{\ssteps}[4]{\sstepGeneric {#1} {#2} * {#3} {#4}}

\newcommand\restr[2]{{% we make the whole thing an ordinary symbol
        \left.\kern-\nulldelimiterspace % automatically resize the bar with \right
        #1 % the function
        \vphantom{\big|} % pretend it's a little taller at normal size
        \right|_{#2} % this is the delimiter
    }}



\begin{document}

% 1. Front pages
\pagenumbering{gobble}
\input{front}

% 2. TOC
\tableofcontents

% 3. Content
\pagenumbering{arabic}
\input{content}

% 4. Bibliography
\bibliography{references}

\end{document}